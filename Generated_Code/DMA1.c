/* ###################################################################
**     THIS COMPONENT MODULE IS GENERATED BY THE TOOL. DO NOT MODIFY IT.
**     Filename    : DMA1.c
**     Project     : ProcessorExpert
**     Processor   : MK60FX512VLQ15
**     Component   : DMA_LDD
**     Version     : Component 01.065, Driver 01.07, CPU db: 3.00.000
**     Compiler    : GNU C Compiler
**     Date/Time   : 2014-07-15, 17:57, # CodeGen: 103
**     Abstract    :
**          This embedded component implements initialization
**          and runtime handling of an on-chip DMA controller.
**     Settings    :
**          Component name                                 : DMA1
**          Device                                         : DMA
**          Settings                                       : 
**            Minor loop mapping                           : Disabled
**            Continuous mode                              : Disabled
**            Halt on error                                : Disabled
**            Debug                                        : Enabled
**          Channel arbitration type                       : Fixed
**          DMA channels                                   : 1
**            Settings of DMA channel                      : DMA_Channel0
**              Channel                                    : DMA_Channel0
**              Channel arbitration type                   : Fixed
**                Priority                                 : 0
**                Channel preemption                       : Disabled
**                Preempt ability                          : Disabled
**              Interrupt service                          : Disabled
**          Initialization                                 : 
**            Enabled in init. code                        : yes
**            Auto initialization                          : no
**          CPU clock/configuration selection              : 
**            Clock configuration 0                        : This component enabled
**            Clock configuration 1                        : This component disabled
**            Clock configuration 2                        : This component disabled
**            Clock configuration 3                        : This component disabled
**            Clock configuration 4                        : This component disabled
**            Clock configuration 5                        : This component disabled
**            Clock configuration 6                        : This component disabled
**            Clock configuration 7                        : This component disabled
**     Contents    :
**         Init                              - LDD_TDeviceData* DMA1_Init(LDD_TUserData *UserDataPtr);
**         Deinit                            - void DMA1_Deinit(LDD_TDeviceData *DeviceDataPtr);
**         AllocateChannel                   - LDD_TError DMA1_AllocateChannel(LDD_TDeviceData *DeviceDataPtr,...
**         FreeChannel                       - LDD_TError DMA1_FreeChannel(LDD_TDeviceData *DeviceDataPtr,...
**         EnableChannel                     - LDD_TError DMA1_EnableChannel(LDD_TDeviceData *DeviceDataPtr,...
**         DisableChannel                    - LDD_TError DMA1_DisableChannel(LDD_TDeviceData *DeviceDataPtr,...
**         StartChannelTransfer              - LDD_TError DMA1_StartChannelTransfer(LDD_TDeviceData *DeviceDataPtr,...
**         CancelChannelTransfer             - LDD_TError DMA1_CancelChannelTransfer(LDD_TDeviceData *DeviceDataPtr,...
**         GetChannelTransferredBytes        - LDD_TError DMA1_GetChannelTransferredBytes(LDD_TDeviceData *DeviceDataPtr,...
**         GetChannelStatus                  - LDD_DMA_TChannelStatus DMA1_GetChannelStatus(LDD_TDeviceData *DeviceDataPtr,...
**         GetChannelLastError               - void DMA1_GetChannelLastError(LDD_TDeviceData *DeviceDataPtr,...
**         SetChannelSourceAddress           - LDD_TError DMA1_SetChannelSourceAddress(LDD_TDeviceData *DeviceDataPtr,...
**         SetChannelDestinationAddress      - LDD_TError DMA1_SetChannelDestinationAddress(LDD_TDeviceData *DeviceDataPtr,...
**         SetChannelSourceTransferSize      - LDD_TError DMA1_SetChannelSourceTransferSize(LDD_TDeviceData *DeviceDataPtr,...
**         SetChannelDestinationTransferSize - LDD_TError DMA1_SetChannelDestinationTransferSize(LDD_TDeviceData...
**         SetChannelByteCount               - LDD_TError DMA1_SetChannelByteCount(LDD_TDeviceData *DeviceDataPtr,...
**         GetChannelDescriptorUpdate        - LDD_TError DMA1_GetChannelDescriptorUpdate(LDD_TDeviceData *DeviceDataPtr,...
**         SetChannelDescriptorUpdate        - LDD_TError DMA1_SetChannelDescriptorUpdate(LDD_TDeviceData *DeviceDataPtr,...
**
**     Copyright : 1997 - 2014 Freescale Semiconductor, Inc. 
**     All Rights Reserved.
**     
**     Redistribution and use in source and binary forms, with or without modification,
**     are permitted provided that the following conditions are met:
**     
**     o Redistributions of source code must retain the above copyright notice, this list
**       of conditions and the following disclaimer.
**     
**     o Redistributions in binary form must reproduce the above copyright notice, this
**       list of conditions and the following disclaimer in the documentation and/or
**       other materials provided with the distribution.
**     
**     o Neither the name of Freescale Semiconductor, Inc. nor the names of its
**       contributors may be used to endorse or promote products derived from this
**       software without specific prior written permission.
**     
**     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
**     ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
**     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
**     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
**     ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
**     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
**     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
**     ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
**     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
**     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
**     
**     http: www.freescale.com
**     mail: support@freescale.com
** ###################################################################*/
/*!
** @file DMA1.c
** @version 01.07
** @brief
**          This embedded component implements initialization
**          and runtime handling of an on-chip DMA controller.
*/         
/*!
**  @addtogroup DMA1_module DMA1 module documentation
**  @{
*/         

/* MODULE DMA1. */

#include "DMA1.h"

/* {Default RTOS Adapter} No RTOS includes */

/* {Default RTOS Adapter} Static object used for simulation of dynamic driver memory allocation */
static DMA1_TDeviceData DeviceDataPtr__DEFAULT_RTOS_ALLOC;
/* Channel numbers initialization table */
static const LDD_DMA_TChannelNumber DMA1_ChannelNumbers[DMA1_CONFIGURED_CHANNELS_NUMBER] = {
  0x00U
};
/* Channel masks initialization table */
static const LDD_DMA_TChannelMask DMA1_ChannelMasks[DMA1_CONFIGURED_CHANNELS_NUMBER] = {
  LDD_DMA_CHANNEL_0_MASK
};
/* Channel interrupts enable initialization table */
static const bool DMA1_ChannelInterrupts[DMA1_CONFIGURED_CHANNELS_NUMBER] = {
  FALSE
};
/* Channel priorities initialization table */
static const LDD_DMA_TChannelPriority DMA1_ChannelPriorities[DMA1_DMA_CHANNELS_NUMBER] = {
  0x00U, 0x01U, 0x02U, 0x03U, 0x04U, 0x05U, 0x06U, 0x07U,
  0x08U, 0x09U, 0x0AU, 0x0BU, 0x0CU, 0x0DU, 0x0EU, 0x0FU,
  0x00U, 0x01U, 0x02U, 0x03U, 0x04U, 0x05U, 0x06U, 0x07U,
  0x08U, 0x09U, 0x0AU, 0x0BU, 0x0CU, 0x0DU, 0x0EU, 0x0FU
};
/* Channel preemption initialization table */
static const bool DMA1_ChannelPreemptions[DMA1_DMA_CHANNELS_NUMBER] = {
  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,
  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,
  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,
  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
};
/* Channel preempt ability initialization table */
static const bool DMA1_ChannelPreemptAbilities[DMA1_DMA_CHANNELS_NUMBER] = {
  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE, 
  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,
  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE, 
  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE
};

/* Internal method prototypes */
static bool GetRecord(LDD_TDeviceData *DeviceDataPtr, LDD_DMA_TTransferDescriptor *DescriptorPtr, DMA1_TDescriptorRecordPtr *DescriptorRecordAddressPtr);
static bool GetChannelNumber(LDD_TDeviceData *DeviceDataPtr, LDD_DMA_TTransferDescriptor *DescriptorPtr, LDD_DMA_TChannelNumber *ChannelNumberPtr);
static bool VerifyDescriptor(LDD_DMA_TTransferDescriptor *DescriptorPtr);
static void InitChannel(DMA1_TDescriptorRecord *DescriptorRecordPtr);

/*
** ===================================================================
**     Method      :  DMA1_Init (component DMA_LDD)
*/
/*!
**     @brief
**         Initializes the device according to design-time
**         configuration properties. Allocates memory for the device
**         data structure. 
**         If the <Enable in init. code> is set to "yes" then the
**         device is also enabled (see the description of the Enable
**         method).
**         This method can be called only once. Before the second call
**         of Init the Deinit method must be called first.
**     @param
**         UserDataPtr     - Pointer to the user or
**                           RTOS specific data. This pointer will be
**                           passed as an event or callback parameter.
**     @return
**                         - Pointer to the device data structure. 
*/
/* ===================================================================*/
LDD_TDeviceData* DMA1_Init(LDD_TUserData *UserDataPtr)
{
  uint8_t i;
  DMA1_TDeviceData *DeviceDataPtr;     /* LDD device structure */
  DMA1_TDescriptorRecord *DescriptorRecordPtr; /* Auxiliary local pointer to internal descriptor records. */

  /* Allocate HAL device structure */
  /* {Default RTOS Adapter} Driver memory allocation: Dynamic allocation is simulated by a pointer to the static object */
  DeviceDataPtr = &DeviceDataPtr__DEFAULT_RTOS_ALLOC;
  DeviceDataPtr->UserDataPtr = UserDataPtr; /* Store the RTOS device structure */
  /* Enable device clock gate */
  /* SIM_SCGC7: DMA=1 */
  SIM_SCGC7 |= SIM_SCGC7_DMA_MASK;
  /* SIM_SCGC6: DMAMUX0=1 */
  SIM_SCGC6 |= SIM_SCGC6_DMAMUX0_MASK;
  DMA_PDD_ClearErrorInterruptEnable(DMA_BASE_PTR, DMA_PDD_ALL_CHANNELS, 0x00U); /* Disable all interrupts */
  DMA_PDD_ClearRequestEnable(DMA_BASE_PTR, DMA_PDD_ALL_CHANNELS, 0x00U); /* Disable all HW requests */
  DMA_PDD_ClearInterruptFlags(DMA_BASE_PTR, DMA_PDD_ALL_CHANNELS, 0x00U); /* Clear request interrupt flags */
  DMA_PDD_ClearErrorFlags(DMA_BASE_PTR, DMA_PDD_ALL_CHANNELS, 0x00U); /* Clear error interrupt flags */
  /* Initialization of channels record field. */
  for(i = 0U; i < DMA1_DMA_CHANNELS_NUMBER; i++) {
    DeviceDataPtr->ChannelRecord[i] = NULL; /* Clear pointer to descriptor record of all channels. */
  }
  /* Initialization of channel and descriptor record fields. */
  for(i = 0U; i < DMA1_CONFIGURED_CHANNELS_NUMBER; i++) {
    DescriptorRecordPtr = &(DeviceDataPtr->DescriptorRecord[i]); /* Store local pointer to descriptor record. */
    DescriptorRecordPtr->ChannelNumber = DMA1_ChannelNumbers[i]; /* Store associated channel number. */
    DescriptorRecordPtr->DescriptorPtr = NULL; /* Set channel as free. */
    DescriptorRecordPtr->Interrupts = DMA1_ChannelInterrupts[i]; /* Store associated channel interrupts enabled/disabled status. */
    DescriptorRecordPtr->Initialized = FALSE; /* Set channel as not initialized. */
    DescriptorRecordPtr->Enabled = FALSE; /* Set channel as disabled. */
    DeviceDataPtr->ChannelRecord[DMA1_ChannelNumbers[i]] = DescriptorRecordPtr; /* Store pointers to descriptor records of fixed channels. */
  }
  /* DMA_CR: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,CX=0,ECX=0,??=0,??=0,??=0,??=0,GRP1PRI=0,GRP0PRI=0,EMLM=0,CLM=0,HALT=0,HOE=0,ERGA=1,ERCA=0,EDBG=0,??=0 */
  DMA_CR = (DMA_CR_GRP1PRI(0x00) | DMA_CR_GRP0PRI(0x00) | DMA_CR_ERGA_MASK);
  /* Initialization of Channel priority registers */
  for (i = 0U; i < (DMA1_DMA_CHANNELS_NUMBER); i++) {
    DMA_PDD_SetChannelPriority(DMA_BASE_PTR, i, DMA1_ChannelPreemptions[i], DMA1_ChannelPreemptAbilities[i], DMA1_ChannelPriorities[i]);
  }
  /* Registration of the device structure */
  PE_LDD_RegisterDeviceStructure(PE_LDD_COMPONENT_DMA1_ID,DeviceDataPtr);
  return ((LDD_TDeviceData *)DeviceDataPtr); /* Return pointer to the data structure */
}

/*
** ===================================================================
**     Method      :  DMA1_Deinit (component DMA_LDD)
*/
/*!
**     @brief
**         Deinitializes the associated peripheral(s) and frees the
**         component internal data structure.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
*/
/* ===================================================================*/
void DMA1_Deinit(LDD_TDeviceData *DeviceDataPtr)
{
  (void)DeviceDataPtr;                 /* Parameter not used, suppress not used argument warning */
  /* Unregistration of the device structure */
  PE_LDD_UnregisterDeviceStructure(PE_LDD_COMPONENT_DMA1_ID);
  /* Deallocation of the device structure */
  /* {Default RTOS Adapter} Driver memory deallocation: Dynamic allocation is simulated, no deallocation code is generated */
  /* Disable device clock gate */
  /* SIM_SCGC7: DMA=0 */
  SIM_SCGC7 &= (uint32_t)~(uint32_t)(SIM_SCGC7_DMA_MASK);
}

/*
** ===================================================================
**     Method      :  DMA1_AllocateChannel (component DMA_LDD)
*/
/*!
**     @brief
**         The method allocates DMA channel for the DMA transfer
**         defined by the transfer descriptor input parameter
**         DescriptorPtr. This method must be called before DMA channel
**         is initialized. Otherwise ERR_NOTAVAIL error code is
**         returned after call of DMA_LDD channel methods.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     @param
**         DescriptorPtr   - Pointer to a DMA
**                           transfer descriptor structure.
**     @return
**                         - Error code, possible codes:
**                           - ERR_OK - OK.
**                           - ERR_SPEED - This device does not work in
**                           the active clock configuration.
**                           - ERR_DISABLED - Component or device is
**                           disabled.
**                           - ERR_NOTAVAIL - There is not any possible
**                           channel with desired features to be
**                           allocated.
*/
/* ===================================================================*/
LDD_TError DMA1_AllocateChannel(LDD_TDeviceData *DeviceDataPtr, LDD_DMA_TTransferDescriptor *DescriptorPtr)
{
  DMA1_TDeviceData *LocalDeviceDataPtr = (DMA1_TDeviceData *)DeviceDataPtr; /* Auxiliary variable - pointer to an internal state structure */
  DMA1_TDescriptorRecord *DescriptorRecordPtr; /* Auxiliary local pointer to internal descriptor records. */
  bool ChannelFound = FALSE;

  if (!DescriptorPtr->ChannelAutoSelection) { /* Fixed channel wanted? */
    DescriptorRecordPtr = LocalDeviceDataPtr->ChannelRecord[DescriptorPtr->ChannelNumber]; /* Store local pointer to internal descriptor record. */
    if (DescriptorRecordPtr->DescriptorPtr == NULL) { /* Is channel free? */
      /* Allocate channel */
      DescriptorRecordPtr->DescriptorPtr = DescriptorPtr;
      ChannelFound = TRUE;
    }
  }
  if (ChannelFound) {
    return ERR_OK;
  }
  else {
    return ERR_NOTAVAIL;
  }
}

/*
** ===================================================================
**     Method      :  DMA1_FreeChannel (component DMA_LDD)
*/
/*!
**     @brief
**         The method frees and disables the DMA channel allocated for
**         the DMA transfer defined by the transfer descriptor input
**         parameter DescriptorPtr.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     @param
**         DescriptorPtr   - Pointer to a DMA
**                           transfer descriptor structure.
**     @return
**                         - Error code, possible codes:
**                           - ERR_OK - OK.
**                           - ERR_SPEED - This device does not work in
**                           the active clock configuration.
**                           - ERR_DISABLED - Component or device is
**                           disabled.
**                           - ERR_NOTAVAIL - There is not any DMA
**                           channel allocated for the selected transfer
**                           descriptor.
*/
/* ===================================================================*/
LDD_TError DMA1_FreeChannel(LDD_TDeviceData *DeviceDataPtr, LDD_DMA_TTransferDescriptor *DescriptorPtr)
{
  LDD_DMA_TChannelNumber ChannelNumber;
  DMA1_TDescriptorRecord *DescriptorRecordPtr; /* Auxiliary local pointer to internal descriptor records. */

  /* Check channel allocation for the transfer descriptor and eventually store pointer to associated descriptor record. */
  if (!GetChannelNumber(DeviceDataPtr, DescriptorPtr, &ChannelNumber)) {
    return ERR_NOTAVAIL;               /* No channel allocated for the transfer. */
  }
  DescriptorRecordPtr = ((DMA1_TDeviceData *)DeviceDataPtr)->ChannelRecord[ChannelNumber];
  DMA_PDD_ClearRequestEnable(DMA_BASE_PTR, DMA_PDD_ONE_CHANNEL, ChannelNumber); /* Disable DMA channel transfer request. */
  DMA_PDD_ClearErrorInterruptEnable(DMA_BASE_PTR, DMA_PDD_ONE_CHANNEL, ChannelNumber); /* Disable channel error interrupt. */
  DMA_PDD_EnableTransferCompleteInterrupt(DMA_BASE_PTR, ChannelNumber, PDD_DISABLE); /* Disable channel transfer complete interrupt. */
  DMA_PDD_EnableTransferHalfInterrupt(DMA_BASE_PTR, ChannelNumber, PDD_DISABLE); /* Disable channel transfer half complete interrupt. */
  DescriptorRecordPtr->Initialized = FALSE; /* Mark channel as not initialized. */
  DescriptorRecordPtr->Enabled = FALSE; /* Mark channel as disabled. */
  DescriptorPtr->ChannelEnabled = FALSE; /* Mark channel as disabled in transfer descriptor. */
  DescriptorRecordPtr->DescriptorPtr = NULL; /* Mark descriptor record as free.  */
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  DMA1_EnableChannel (component DMA_LDD)
*/
/*!
**     @brief
**         The method initializes and/or enables the DMA channel
**         allocated for the DMA transfer defined by the transfer
**         descriptor input parameter DescriptorPtr. First call of this
**         method on given DMA channel initializes it and enables HW
**         requests if Peripheral device or Always enabled trigger
**         source is selected in transfer descriptor Trigger source
**         type item. This method can be also used together with
**         Disable method to temporary switch On/Off the DMA channel HW
**         requests. In such case DMA channel registers are not
**         reinitialized again. New initialization of DMA channel can
**         be done via SetChannelDescriptorUpdate method which
**         reinitializes whole channel with new transfer descriptor.
**         After calling of EnableChannel method channel status is set
**         to LDD_DMA_IDLE.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     @param
**         DescriptorPtr   - Pointer to a DMA
**                           transfer descriptor structure.
**     @return
**                         - Error code, possible codes:
**                           - ERR_OK - OK.
**                           - ERR_SPEED - This device does not work in
**                           the active clock configuration.
**                           - ERR_DISABLED - Component or device is
**                           disabled.
**                           - ERR_NOTAVAIL - There is not any DMA
**                           channel allocated for the selected transfer
**                           descriptor.
**                           - ERR_PARAM_DATA - Transfer descriptor data
**                           are inconsistent.
*/
/* ===================================================================*/
LDD_TError DMA1_EnableChannel(LDD_TDeviceData *DeviceDataPtr, LDD_DMA_TTransferDescriptor *DescriptorPtr)
{
  LDD_DMA_TChannelNumber ChannelNumber;
  DMA1_TDescriptorRecord *DescriptorRecordPtr;

  /* Check channel allocation for the transfer descriptor and eventually store pointer to associated descriptor record. */
  if (!GetRecord(DeviceDataPtr, DescriptorPtr, &DescriptorRecordPtr)) {
    return ERR_NOTAVAIL;               /* No channel allocated for the transfer. */
  }
  /* Transfer descriptor consistency test - this test can be disabled by setting the "Ignore range checking"
     property to the "yes" value in the "Configuration inspector" */
  if (!VerifyDescriptor(DescriptorPtr)) {
    return ERR_PARAM_DATA;
  }
  ChannelNumber = DescriptorRecordPtr->ChannelNumber; /* Save local auxiliary channel number. */
  if (!DescriptorRecordPtr->Initialized) { /* Is channel already initialized? */
    /* If channel is not initialized yet, initialize and enable it */
    InitChannel(DescriptorRecordPtr);
    /* {Default RTOS Adapter} Critical section begin, general PE function is used */
    EnterCritical();
    DescriptorRecordPtr->Initialized = TRUE; /* Mark channel as initialized. */
    DescriptorRecordPtr->Enabled = TRUE; /* Mark channel as enabled. */
    DescriptorPtr->ChannelEnabled = TRUE; /* Mark channel as enabled in transfer descriptor. */
    if (DescriptorPtr->OnError) {      /* Is error event enabled? */
      DMA_PDD_SetErrorInterruptEnable(DMA_BASE_PTR, DMA_PDD_ONE_CHANNEL, ChannelNumber);
    }
    if (DescriptorPtr->OnComplete) {   /* Is transfer complete event enabled? */
      DMA_PDD_EnableTransferCompleteInterrupt(DMA_BASE_PTR, ChannelNumber, PDD_ENABLE);
    }
    if (DescriptorPtr->OnHalfComplete) { /* Is transfer half complete feature enabled? */
      DMA_PDD_EnableTransferHalfInterrupt(DMA_BASE_PTR, ChannelNumber, PDD_ENABLE);
    }
    /* Set up DMAMUX0 (no channel connected to DMAMUX1 used) */
    DMAMUX_PDD_WriteChannelConfigurationReg(DMAMUX0_BASE_PTR, ChannelNumber, 0U); /* Clear DMA MUX channel source register. */
    if (DescriptorPtr->TriggerType != LDD_DMA_SW_TRIGGER) { /* SW trigger doesn't need MUX channel nor enabled hardware requests. */
      DMAMUX_PDD_SetChannelSource(DMAMUX0_BASE_PTR, ChannelNumber, DescriptorPtr->TriggerSource); /* Set MUX channel source. */
      if (DescriptorPtr->PeriodicTrigger) { /* Periodic trigger needed? */
        DMAMUX_PDD_EnableTrigger(DMAMUX0_BASE_PTR, ChannelNumber, PDD_ENABLE);
      }
      DMAMUX_PDD_EnableChannel(DMAMUX0_BASE_PTR, ChannelNumber, PDD_ENABLE); /* Enable channel. */
      DMA_PDD_SetRequestEnable(DMA_BASE_PTR, DMA_PDD_ONE_CHANNEL, ChannelNumber); /* Enable DMA transfer request. */
    }
    /* {Default RTOS Adapter} Critical section end, general PE function is used */
    ExitCritical();
  }
  else {
    /* If channel has already been initialized then enable it only */
    /* {Default RTOS Adapter} Critical section begin, general PE function is used */
    EnterCritical();
    DescriptorRecordPtr->Enabled = TRUE; /* Mark channel as enabled. */
    DescriptorPtr->ChannelEnabled = TRUE; /* Mark channel as enabled in transfer descriptor. */
    if (DescriptorPtr->TriggerType != LDD_DMA_SW_TRIGGER) { /* SW trigger doesn't need enabled hardware requests. */
      DMA_PDD_SetRequestEnable(DMA_BASE_PTR, DMA_PDD_ONE_CHANNEL, DescriptorRecordPtr->ChannelNumber); /* Enable DMA transfer request. */
    }
    DMA_PDD_ClearChannelActivityFlags(DMA_BASE_PTR, DescriptorRecordPtr->ChannelNumber, DMA_PDD_TRANSFER_DONE_FLAG); /* Clear DMA transfer done status flag. */
    /* {Default RTOS Adapter} Critical section end, general PE function is used */
    ExitCritical();
  }
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  DMA1_DisableChannel (component DMA_LDD)
*/
/*!
**     @brief
**         The method disables the DMA channel allocated for the DMA
**         transfer defined by the transfer descriptor input parameter
**         DescriptorPtr and disables HW requests services. However, it
**         is still possible to start transfer explicitly as SW
**         transfer requests via StartChannelTransfer method. After
**         calling of DisableChannel method channel status is set to
**         LDD_DMA_IDLE.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     @param
**         DescriptorPtr   - Pointer to a DMA
**                           transfer descriptor structure.
**     @return
**                         - Error code, possible codes:
**                           - ERR_OK - OK.
**                           - ERR_SPEED - This device does not work in
**                           the active clock configuration.
**                           - ERR_DISABLED - Component or device is
**                           disabled.
**                           - ERR_NOTAVAIL - There is not any DMA
**                           channel allocated for the selected transfer
**                           descriptor.
*/
/* ===================================================================*/
LDD_TError DMA1_DisableChannel(LDD_TDeviceData *DeviceDataPtr, LDD_DMA_TTransferDescriptor *DescriptorPtr)
{
  LDD_DMA_TRecordNumber ChannelNumber;
  DMA1_TDescriptorRecord *DescriptorRecordPtr;

  /* Check channel allocation for the transfer descriptor and eventually store pointer to associated descriptor record. */
  if (!GetRecord(DeviceDataPtr, DescriptorPtr, &DescriptorRecordPtr)) {
    return ERR_NOTAVAIL;               /* No channel allocated for the transfer. */
  }
  ChannelNumber = DescriptorRecordPtr->ChannelNumber; /* Save local auxiliary channel number. */
  /* {Default RTOS Adapter} Critical section begin, general PE function is used */
  EnterCritical();
  DescriptorRecordPtr->Enabled = FALSE; /* Mark channel as disabled. */
  DescriptorPtr->ChannelEnabled = FALSE; /* Mark channel as disabled in transfer descriptor. */
  DMA_PDD_ClearRequestEnable(DMA_BASE_PTR, DMA_PDD_ONE_CHANNEL, ChannelNumber); /* Disable DMA channel transfer request. */
  /* {Default RTOS Adapter} Critical section end, general PE function is used */
  ExitCritical();
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  DMA1_StartChannelTransfer (component DMA_LDD)
*/
/*!
**     @brief
**         The method starts DMA transfer on the allocated DMA channel
**         defined by the transfer descriptor input parameter
**         DescriptorPtr. This methods initiates explicit SW transfer
**         request and can be called after channel is initialized by
**         first calling of EnableChannel method. Explicit SW transfer
**         request is serviced regardless of disabling HW requests
**         after calling of the DisableChannel method.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     @param
**         DescriptorPtr   - Pointer to a DMA
**                           transfer descriptor structure.
**     @return
**                         - Error code, possible codes:
**                           - ERR_OK - OK.
**                           - ERR_SPEED - This device does not work in
**                           the active clock configuration.
**                           - ERR_DISABLED - Component or device is
**                           disabled.
**                           - ERR_NOTAVAIL - There is not any DMA
**                           channel allocated for the selected transfer
**                           descriptor.
*/
/* ===================================================================*/
LDD_TError DMA1_StartChannelTransfer(LDD_TDeviceData *DeviceDataPtr, LDD_DMA_TTransferDescriptor *DescriptorPtr)
{
  DMA1_TDescriptorRecord *DescriptorRecordPtr;

  /* Check channel allocation for the transfer descriptor and eventually store pointer to associated descriptor record. */
  if (!GetRecord(DeviceDataPtr, DescriptorPtr, &DescriptorRecordPtr)) {
    return ERR_NOTAVAIL;               /* No channel allocated for the transfer. */
  }
  if (!DescriptorRecordPtr->Initialized) {
    return ERR_NOTAVAIL;
  }
  DMA_PDD_StartTransfer(DMA_BASE_PTR, DMA_PDD_ONE_CHANNEL, DescriptorRecordPtr->ChannelNumber); /* Explicit start of transfer. */
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  DMA1_CancelChannelTransfer (component DMA_LDD)
*/
/*!
**     @brief
**         The method cancels DMA transfer on channel specified by the
**         transfer descriptor input parameter DescriptorPtr. The
**         cancel takes effect after the last write of the current
**         read/write sequence and the channel retires as if the
**         request was serviced normally.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     @param
**         DescriptorPtr   - Pointer to a DMA
**                           transfer descriptor structure.
**     @return
**                         - Error code, possible codes:
**                           - ERR_OK - OK.
**                           - ERR_SPEED - This device does not work in
**                           the active clock configuration.
**                           - ERR_DISABLED - Component or device is
**                           disabled.
**                           - ERR_NOTAVAIL - There is not any DMA
**                           channel allocated for the selected transfer
**                           descriptor.
*/
/* ===================================================================*/
LDD_TError DMA1_CancelChannelTransfer(LDD_TDeviceData *DeviceDataPtr, LDD_DMA_TTransferDescriptor *DescriptorPtr)
{
  LDD_DMA_TRecordNumber i;

  /* Try find match between tested descriptor pointer and stored records. */
  for (i = 0U; i < DMA1_CONFIGURED_CHANNELS_NUMBER; i++) {
    if (((DMA1_TDeviceData *)DeviceDataPtr)->DescriptorRecord[i].DescriptorPtr == DescriptorPtr) {
      DMA_PDD_CancelTransfer(DMA_BASE_PTR); /* Cancel transfer. */
      return ERR_OK;
    }
  }
  return ERR_NOTAVAIL;                 /* Transfer descriptor is not associated with any channel. */
}

/*
** ===================================================================
**     Method      :  DMA1_GetChannelTransferredBytes (component DMA_LDD)
*/
/*!
**     @brief
**         The method gets a number of transferred bytes by DMA
**         transfer defined by the transfer descriptor input parameter
**         DescriptorPtr. Value of transferred bytes is stored in
**         variable defined by its address and reflects either number
**         of bytes transferred in currently active transfer or number
**         of bytes transferred in last completed transfer.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     @param
**         DescriptorPtr   - Pointer to a DMA
**                           transfer descriptor structure.
**     @param
**         ByteCountPtr    - Pointer to number of
**                           transferred bytes.
**     @return
**                         - Error code, possible codes:
**                           - ERR_OK - OK.
**                           - ERR_SPEED - This device does not work in
**                           the active clock configuration.
**                           - ERR_DISABLED - Component or device is
**                           disabled.
**                           - ERR_NOTAVAIL - There is not any DMA
**                           channel allocated for the selected transfer
**                           descriptor.
*/
/* ===================================================================*/
LDD_TError DMA1_GetChannelTransferredBytes(LDD_TDeviceData *DeviceDataPtr, LDD_DMA_TTransferDescriptor *DescriptorPtr, LDD_DMA_TByteCount *ByteCountPtr)
{
  LDD_DMA_TChannelNumber ChannelNumber;
  uint16_t LocalByteCount = 0U;

  /* Check channel allocation for the transfer descriptor and eventually store associated DMA channel number. */
  if (!GetChannelNumber(DeviceDataPtr, DescriptorPtr, &ChannelNumber)) {
    return ERR_NOTAVAIL;               /* No channel allocated for the transfer. */
  }
  if (!DescriptorPtr->OuterLoopChannelLink) {
    LocalByteCount = DMA_PDD_GetBeginningMajorLoopCount15(DMA_BASE_PTR, ChannelNumber); /* Get beginning transfers number. */
    if (DMA_PDD_GetDoneFlag(DMA_BASE_PTR, ChannelNumber) == 0x00U) { /* Is any transfer currently pending? */
      LocalByteCount = LocalByteCount - DMA_PDD_GetCurrentMajorLoopCount15(DMA_BASE_PTR, ChannelNumber); /* Subtract current transfers number to get number of processed major loops (serviced requests). */
    }
  }
  else {
    LocalByteCount = DMA_PDD_GetBeginningMajorLoopCount9(DMA_BASE_PTR, ChannelNumber); /* Get beginning transfers number. */
    if (DMA_PDD_GetDoneFlag(DMA_BASE_PTR, ChannelNumber) == 0x00U) { /* Is any transfer currently pending? */
      LocalByteCount = LocalByteCount - DMA_PDD_GetCurrentMajorLoopCount9(DMA_BASE_PTR, ChannelNumber); /* Subtract current transfers number to get number of processed major loops (serviced requests). */
    }
  }
  *ByteCountPtr = (LDD_DMA_TByteCount)LocalByteCount * (DescriptorPtr->ByteCount); /* Multiply by number of bytes per one request to get number of transferred bytes. */
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  DMA1_GetChannelStatus (component DMA_LDD)
*/
/*!
**     @brief
**         The method gets a status of the DMA channel allocated for
**         the DMA transfer defined by the transfer descriptor input
**         parameter DescriptorPtr. This method is intended to perform
**         fast check of DMA channel transfer status and no validity or
**         consistency checks are performed. Possible values are
**         LDD_DMA_IDLE returned after enabling or disabling channel or
**         between separate transfers of nested transfer operation.
**         During the DMA transfer active operation LDD_DMA_BUSY is
**         returned. LDD_DMA_DONE is returned after cycle-steal, single
**         or nested transfer completes and before start of another
**         transfer or before channel enable or disable. If DMA error
**         was detected, LDD_DMA_ERR is returned.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     @param
**         DescriptorPtr   - Pointer to a DMA
**                           transfer descriptor structure.
**     @return
**                         - DMA channel status.
*/
/* ===================================================================*/
LDD_DMA_TChannelStatus DMA1_GetChannelStatus(LDD_TDeviceData *DeviceDataPtr, LDD_DMA_TTransferDescriptor *DescriptorPtr)
{
  (void)DeviceDataPtr;                 /* Parameter not used, suppress not used argument warning */
  if ((DMA_PDD_GetErrorStatusFlags(DMA_BASE_PTR)) != 0x00U) { /* Channel error check. */
    return LDD_DMA_ERROR;
  }
  if (DMA_PDD_GetDoneFlag(DMA_BASE_PTR, DescriptorPtr->ChannelNumber) != 0x00U) { /* Channel transfer done check. */
    return LDD_DMA_DONE;
  }
  if (DMA_PDD_GetActiveFlag(DMA_BASE_PTR, DescriptorPtr->ChannelNumber) == 0x00U) { /* Channel activity check. */
    return LDD_DMA_IDLE;
  }
  return LDD_DMA_BUSY;
}

/*
** ===================================================================
**     Method      :  DMA1_GetChannelLastError (component DMA_LDD)
*/
/*!
**     @brief
**         Returns last recorded channel error. Returned error
**         structure is passed as pointer parameter. Structure contains
**         last recorded error status and channel number associated
**         with this error record. Error mask constants can be used to
**         identify stored error type.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     @param
**         DescriptorPtr   - Pointer to a DMA
**                           transfer descriptor structure.
**     @param
**         ErrorStatusPtr  - Pointer to DMA error
**                           status structure.
*/
/* ===================================================================*/
void DMA1_GetChannelLastError(LDD_TDeviceData *DeviceDataPtr, LDD_DMA_TTransferDescriptor *DescriptorPtr, LDD_DMA_TError *ErrorStatusPtr)
{
  (void)DeviceDataPtr;                 /* Parameter not used, suppress not used argument warning */
  (void)DescriptorPtr;                 /* Parameter not used, suppress not used argument warning */
  ErrorStatusPtr->ErrorFlags = DMA_PDD_GetErrorStatusFlags(DMA_BASE_PTR); /* Store recorded error flags mask. */
  ErrorStatusPtr->ChannelNumber = DMA_PDD_GetErrorStatusChannel(DMA_BASE_PTR); /* Store channel number. */
}

/*
** ===================================================================
**     Method      :  DMA1_SetChannelSourceAddress (component DMA_LDD)
*/
/*!
**     @brief
**         The method sets an source address for data to be transferred
**         by the DMA channel allocated for the DMA transfer defined by
**         the transfer descriptor parameter DescriptorPtr. This method
**         can be used to update DMA transfer source address when DMA
**         channel is enabled. New source address is stored in transfer
**         descriptor and written to associated DMA channel registers.
**         The new source address can be optionally checked for
**         consistency with rest of the transfer descriptor data.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     @param
**         DescriptorPtr   - Pointer to a DMA
**                           transfer descriptor structure.
**     @param
**         Address         - Address of source data for a DMA
**                           channel allocated for a DMA transfer
**                           descriptor defined by the TCD parameter.
**     @return
**                         - Error code, possible codes:
**                           - ERR_OK - OK.
**                           - ERR_SPEED - This device does not work in
**                           the active clock configuration.
**                           - ERR_DISABLED - Component or device is
**                           disabled.
**                           - ERR_NOTAVAIL - There is not any DMA
**                           channel allocated for the selected transfer
**                           descriptor.
**                           - ERR_PARAM_DATA - Selected source address
**                           is inconsistent with rest of transfer
**                           descriptor data.
*/
/* ===================================================================*/
LDD_TError DMA1_SetChannelSourceAddress(LDD_TDeviceData *DeviceDataPtr, LDD_DMA_TTransferDescriptor *DescriptorPtr, LDD_DMA_TAddress Address)
{
  LDD_DMA_TAddress LocalAddress;
  LDD_DMA_TChannelNumber ChannelNumber;

  /* Check channel allocation for the transfer descriptor and eventually store associated DMA channel number. */
  if (!GetChannelNumber(DeviceDataPtr, DescriptorPtr, &ChannelNumber)) {
    return ERR_NOTAVAIL;               /* No channel allocated for the transfer. */
  }
  /* New transfer descriptor consistency test - this test can be disabled by setting the "Ignore range checking"
     property to the "yes" value in the "Configuration inspector" */
  LocalAddress = DescriptorPtr->SourceAddress; /* Save actual address. */
  DescriptorPtr->SourceAddress = Address; /* Store new address in transfer descriptor. */
  if (!VerifyDescriptor(DescriptorPtr)) { /* Test consistency of new transfer descriptor. */
    DescriptorPtr->SourceAddress = LocalAddress; /* If failed, restore previous value. */
    return ERR_PARAM_DATA;
  }
  DMA_PDD_SetSourceAddress(DMA_BASE_PTR, ChannelNumber, Address);
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  DMA1_SetChannelDestinationAddress (component DMA_LDD)
*/
/*!
**     @brief
**         The method sets an destination address for data to be
**         transferred by the DMA channel allocated for the DMA
**         transfer defined by the transfer descriptor parameter
**         DescriptorPtr. This method can be used to update DMA
**         transfer destination address when DMA channel is enabled.
**         New destination address is stored in transfer descriptor and
**         written to associated DMA channel registers. The new
**         destination address can be optionally checked for
**         consistency with rest of the transfer descriptor data.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     @param
**         DescriptorPtr   - Pointer to a DMA
**                           transfer descriptor structure.
**     @param
**         Address         - Address of a destination data to
**                           be transferred to by the DMA channel
**                           allocated for a DMA transfer descriptor
**                           defined by the TCD parameter.
**     @return
**                         - Error code, possible codes:
**                           - ERR_OK - OK.
**                           - ERR_SPEED - This device does not work in
**                           the active clock configuration.
**                           - ERR_DISABLED - Component or device is
**                           disabled.
**                           - ERR_NOTAVAIL - There is not any DMA
**                           channel allocated for the selected transfer
**                           descriptor.
**                           - ERR_PARAM_DATA - Selected source address
**                           is inconsistent with rest of transfer
**                           descriptor data.
*/
/* ===================================================================*/
LDD_TError DMA1_SetChannelDestinationAddress(LDD_TDeviceData *DeviceDataPtr, LDD_DMA_TTransferDescriptor *DescriptorPtr, LDD_DMA_TAddress Address)
{
  LDD_DMA_TAddress LocalAddress;
  LDD_DMA_TChannelNumber ChannelNumber;

  /* Check channel allocation for the transfer descriptor and eventually store associated DMA channel number. */
  if (!GetChannelNumber(DeviceDataPtr, DescriptorPtr, &ChannelNumber)) {
    return ERR_NOTAVAIL;               /* No channel allocated for the transfer. */
  }
  /* New transfer descriptor consistency test - this test can be disabled by setting the "Ignore range checking"
     property to the "yes" value in the "Configuration inspector" */
  LocalAddress = DescriptorPtr->DestinationAddress; /* Save actual address. */
  DescriptorPtr->DestinationAddress = Address; /* Store new address in transfer descriptor. */
  if (!VerifyDescriptor(DescriptorPtr)) { /* Test consistency of new transfer descriptor. */
    DescriptorPtr->DestinationAddress = LocalAddress; /* If failed, restore previous value. */
    return ERR_PARAM_DATA;
  }
  DMA_PDD_SetDestinationAddress(DMA_BASE_PTR, ChannelNumber, Address);
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  DMA1_SetChannelSourceTransferSize (component DMA_LDD)
*/
/*!
**     @brief
**         The method sets an source transfer size for data to be
**         transferred by the DMA channel allocated for the DMA
**         transfer defined by the transfer descriptor parameter
**         DescriptorPtr. This method can be used to update DMA
**         transfer source transfer size when DMA channel is enabled.
**         New source transfer size is stored in transfer descriptor
**         and written to associated DMA channel registers. The new
**         source transfer size can be optionally checked for
**         consistency with rest of the transfer descriptor data.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     @param
**         DescriptorPtr   - Pointer to a DMA
**                           transfer descriptor structure.
**     @param
**         TransferSize    - Source transfer size.
**     @return
**                         - Error code, possible codes:
**                           - ERR_OK - OK.
**                           - ERR_SPEED - This device does not work in
**                           the active clock configuration.
**                           - ERR_DISABLED - Component or device is
**                           disabled.
**                           - ERR_NOTAVAIL - There is not any DMA
**                           channel allocated for the selected transfer
**                           descriptor.
**                           - ERR_PARAM_DATA - Selected source transfer
**                           size is inconsistent with rest of transfer
**                           descriptor data.
*/
/* ===================================================================*/
LDD_TError DMA1_SetChannelSourceTransferSize(LDD_TDeviceData *DeviceDataPtr, LDD_DMA_TTransferDescriptor *DescriptorPtr, LDD_DMA_TTransferSize TransferSize)
{
  LDD_DMA_TTransferSize LocalSize;
  LDD_DMA_TChannelNumber ChannelNumber;

  /* Check channel allocation for the transfer descriptor and eventually store associated DMA channel number. */
  if (!GetChannelNumber(DeviceDataPtr, DescriptorPtr, &ChannelNumber)) {
    return ERR_NOTAVAIL;               /* No channel allocated for the transfer. */
  }
  /* New transfer descriptor consistency test - this test can be disabled by setting the "Ignore range checking"
     property to the "yes" value in the "Configuration inspector" */
  LocalSize = DescriptorPtr->SourceTransferSize; /* Save actual transfer size. */
  DescriptorPtr->SourceTransferSize = TransferSize; /* Store new transfer size in transfer descriptor. */
  if (!VerifyDescriptor(DescriptorPtr)) { /* Test consistency of new transfer descriptor. */
    DescriptorPtr->SourceTransferSize = LocalSize; /* If failed, restore previous value. */
    return ERR_PARAM_DATA;
  }
  DMA_PDD_SetSourceDataTransferSize(DMA_BASE_PTR, ChannelNumber, TransferSize);
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  DMA1_SetChannelDestinationTransferSize (component DMA_LDD)
*/
/*!
**     @brief
**         The method sets an destination transfer size for data to be
**         transferred by the DMA channel allocated for the DMA
**         transfer defined by the transfer descriptor parameter
**         DescriptorPtr. This method can be used to update DMA
**         transfer destination transfer size when DMA channel is
**         enabled. New destination transfer size is stored in transfer
**         descriptor and written to associated DMA channel registers.
**         The new destination transfer size can be optionally checked
**         for consistency with rest of the transfer descriptor data.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     @param
**         DescriptorPtr   - Pointer to a DMA
**                           transfer descriptor structure.
**     @param
**         TransferSize    - Destination transfer
**                           size.
**     @return
**                         - Error code, possible codes:
**                           - ERR_OK - OK.
**                           - ERR_SPEED - This device does not work in
**                           the active clock configuration.
**                           - ERR_DISABLED - Component or device is
**                           disabled.
**                           - ERR_NOTAVAIL - There is not any DMA
**                           channel allocated for the selected transfer
**                           descriptor.
**                           - ERR_PARAM_DATA - Selected destination
**                           transfer size is inconsistent with rest of
**                           transfer descriptor data.
*/
/* ===================================================================*/
LDD_TError DMA1_SetChannelDestinationTransferSize(LDD_TDeviceData *DeviceDataPtr, LDD_DMA_TTransferDescriptor *DescriptorPtr, LDD_DMA_TTransferSize TransferSize)
{
  LDD_DMA_TTransferSize LocalSize;
  LDD_DMA_TChannelNumber ChannelNumber;

  /* Check channel allocation for the transfer descriptor and eventually store associated DMA channel number. */
  if (!GetChannelNumber(DeviceDataPtr, DescriptorPtr, &ChannelNumber)) {
    return ERR_NOTAVAIL;               /* No channel allocated for the transfer. */
  }
  /* New transfer descriptor consistency test - this test can be disabled by setting the "Ignore range checking"
     property to the "yes" value in the "Configuration inspector" */
  LocalSize = DescriptorPtr->DestinationTransferSize; /* Save actual transfer size. */
  DescriptorPtr->DestinationTransferSize = TransferSize; /* Store new transfer size in transfer descriptor. */
  if (!VerifyDescriptor(DescriptorPtr)) { /* Test consistency of new transfer descriptor. */
    DescriptorPtr->DestinationTransferSize = LocalSize; /* If failed, restore previous value. */
    return ERR_PARAM_DATA;
  }
  DMA_PDD_SetDestinationDataTransferSize(DMA_BASE_PTR, ChannelNumber, TransferSize);
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  DMA1_SetChannelByteCount (component DMA_LDD)
*/
/*!
**     @brief
**         The method sets a byte count (size of data) to be
**         transferred by the DMA channel allocated for the DMA
**         transfer defined by the transfer descriptor input parameter
**         DescriptorPtr. This method can be used to update DMA
**         transfer byte count when DMA channel is enabled. New
**         transfer byte count is stored in transfer descriptor and
**         written to associated DMA channel registers. The new
**         transfer byte count can be optionally checked for
**         consistency with rest of the transfer descriptor data. If
**         nested operation is used, the method sets the minor (inner)
**         loop byte count.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     @param
**         DescriptorPtr   - Pointer to a DMA
**                           transfer descriptor structure.
**     @param
**         ByteCount       - Byte count (size of data) to
**                           be transferred by the DMA channel allocated
**                           for a DMA transfer descriptor defined by
**                           the TCD parameter.
**     @return
**                         - Error code, possible codes:
**                           - ERR_OK - OK.
**                           - ERR_SPEED - This device does not work in
**                           the active clock configuration.
**                           - ERR_DISABLED - Component or device is
**                           disabled.
**                           - ERR_NOTAVAIL - There is not any DMA
**                           channel allocated for the selected transfer
**                           descriptor.
**                           - ERR_PARAM_DATA - Selected byte count is
**                           inconsistent with rest of transfer
**                           descriptor data.
*/
/* ===================================================================*/
LDD_TError DMA1_SetChannelByteCount(LDD_TDeviceData *DeviceDataPtr, LDD_DMA_TTransferDescriptor *DescriptorPtr, LDD_DMA_TByteCount ByteCount)
{
  LDD_DMA_TByteCount LocalByteCount;
  LDD_DMA_TChannelNumber ChannelNumber;

  /* Check channel allocation for the transfer descriptor and eventually store associated DMA channel number. */
  if (!GetChannelNumber(DeviceDataPtr, DescriptorPtr, &ChannelNumber)) {
    return ERR_NOTAVAIL;               /* No channel allocated for the transfer. */
  }
  /* Transferred byte count range test - this test can be disabled by setting the "Ignore range checking"
     property to the "yes" value in the "Configuration inspector" */
  if (ByteCount > DMA1_MAX_BYTE_COUNT) { /* Test if ByteCount is in correct range. */
    return ERR_PARAM_DATA;
  }   
  /* New transfer descriptor consistency test - this test can be disabled by setting the "Ignore range checking"
     property to the "yes" value in the "Configuration inspector" */
  LocalByteCount = DescriptorPtr->ByteCount; /* Save actual byte count. */
  DescriptorPtr->ByteCount = ByteCount; /* Store new byte count in transfer descriptor. */
  if (!VerifyDescriptor(DescriptorPtr)) { /* Test consistency of new transfer descriptor. */
    DescriptorPtr->ByteCount = LocalByteCount; /* If failed, restore previous value. */
    return ERR_PARAM_DATA;
  }
  DMA_PDD_SetByteCount32(DMA_BASE_PTR, ChannelNumber, ByteCount);
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  DMA1_SetChannelDescriptorUpdate (component DMA_LDD)
*/
/*!
**     @brief
**         The method updates DMA channel allocated by transfer
**         descriptor defined by DescriptorPtr. Allocated DMA channel
**         registers are reinitialized with new values from transfer
**         descriptor structure. New tansfer descriptor is tested for
**         data consistency. The method can be called only if the
**         channel is disabled.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     @param
**         DescriptorPtr   - Pointer to a DMA
**                           transfer descriptor structure.
**     @return
**                         - Error code, possible codes:
**                           - ERR_OK - OK.
**                           - ERR_SPEED - This device does not work in
**                           the active clock configuration.
**                           - ERR_DISABLED - Component or device is
**                           disabled.
**                           - ERR_NOTAVAIL - There is not any DMA
**                           channel allocated for the selected transfer
**                           descriptor or allocated channel is enabled.
**                           - ERR_PARAM_DATA - Selected transfer
**                           descriptor is inconsistent.
*/
/* ===================================================================*/
LDD_TError DMA1_SetChannelDescriptorUpdate(LDD_TDeviceData *DeviceDataPtr, LDD_DMA_TTransferDescriptor *DescriptorPtr)
{
  DMA1_TDescriptorRecord *DescriptorRecordPtr;
  LDD_DMA_TChannelNumber ChannelNumber;

  /* Check channel allocation for the transfer descriptor and eventually store associated DMA channel number. */
  if (!GetRecord(DeviceDataPtr, DescriptorPtr, &DescriptorRecordPtr)) {
    return ERR_NOTAVAIL;               /* No channel allocated for the transfer. */
  }
  else {
    if (DescriptorRecordPtr->Enabled) { /* Is channel enabled? */
      return ERR_NOTAVAIL;             /* If yes, channel descriptor can't be updated. */
    }
  }
  /* New transfer descriptor consistency test - this test can be disabled by setting the "Ignore range checking"
     property to the "yes" value in the "Configuration inspector" */
  if ((!VerifyDescriptor(DescriptorPtr)) || (DescriptorRecordPtr->ChannelNumber != DescriptorPtr->ChannelNumber)) {
    return ERR_PARAM_DATA;             /* Return transfer descriptor inconsistency error. */
  }
  DescriptorRecordPtr->Initialized = FALSE; /* Prevents from explicit SW request invokation. */
  ChannelNumber = DescriptorRecordPtr->ChannelNumber;
  InitChannel(DescriptorRecordPtr);    /* Initialize DMA channel. */
  /* {Default RTOS Adapter} Critical section begin, general PE function is used */
  EnterCritical();
  DescriptorRecordPtr->Initialized = TRUE; /* Mark channel as initialized. */
  if (DescriptorPtr->OnError) {        /* Is error event enabled? */
    DMA_PDD_SetErrorInterruptEnable(DMA_BASE_PTR, DMA_PDD_ONE_CHANNEL, ChannelNumber);
  }
  if (DescriptorPtr->OnComplete) {     /* Is transfer complete event enabled? */
    DMA_PDD_EnableTransferCompleteInterrupt(DMA_BASE_PTR, ChannelNumber, PDD_ENABLE);
  }
  if (DescriptorPtr->OnHalfComplete) { /* Is transfer half complete feature enabled? */
    DMA_PDD_EnableTransferHalfInterrupt(DMA_BASE_PTR, ChannelNumber, PDD_ENABLE);
  }
  /* Set up DMAMUX0 (no channel connected to DMAMUX1 used) */
  DMAMUX_PDD_WriteChannelConfigurationReg(DMAMUX0_BASE_PTR, ChannelNumber, 0U); /* Clear DMA MUX channel source register. */
  if (DescriptorPtr->TriggerType != LDD_DMA_SW_TRIGGER) { /* SW trigger doesn't need MUX channel nor enabled hardware requests. */
    DMAMUX_PDD_SetChannelSource(DMAMUX0_BASE_PTR, ChannelNumber, DescriptorPtr->TriggerSource); /* Set MUX channel source. */
    if (DescriptorPtr->PeriodicTrigger) { /* Periodic trigger needed? */
      DMAMUX_PDD_EnableTrigger(DMAMUX0_BASE_PTR, ChannelNumber, PDD_ENABLE);
    }
    DMAMUX_PDD_EnableChannel(DMAMUX0_BASE_PTR, ChannelNumber, PDD_ENABLE); /* Enable channel. */
    if (DescriptorRecordPtr->Enabled) { /* Enable requests? */
      DMA_PDD_SetRequestEnable(DMA_BASE_PTR, DMA_PDD_ONE_CHANNEL, ChannelNumber); /* Enable DMA transfer request. */
    }
  }
  /* {Default RTOS Adapter} Critical section end, general PE function is used */
  ExitCritical();
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  DMA1_GetChannelDescriptorUpdate (component DMA_LDD)
*/
/*!
**     @brief
**         The method gets transfer descriptor parameters of the DMA
**         channel allocated for the component. Allocated channel is
**         identified by the transfer descriptor structure address and
**         it is updated with values from the allocated DMA channel
**         registers. The method can be called only if the channel is
**         disabled.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     @param
**         DescriptorPtr   - Pointer to a DMA
**                           transfer descriptor structure.
**     @return
**                         - Error code, possible codes:
**                           - ERR_OK - OK.
**                           - ERR_SPEED - This device does not work in
**                           the active clock configuration.
**                           - ERR_DISABLED - Component or device is
**                           disabled.
**                           - ERR_NOTAVAIL - There is not any DMA
**                           channel allocated for the selected transfer
**                           descriptor or allocated channel is enabled.
*/
/* ===================================================================*/
LDD_TError DMA1_GetChannelDescriptorUpdate(LDD_TDeviceData *DeviceDataPtr, LDD_DMA_TTransferDescriptor *DescriptorPtr)
{
  DMA1_TDescriptorRecord *DescriptorRecordPtr;
  LDD_DMA_TChannelNumber ChannelNumber;

  /* Check channel allocation for the transfer descriptor and eventually store associated DMA channel number. */
  if (!GetRecord(DeviceDataPtr, DescriptorPtr, &DescriptorRecordPtr)) {
    return ERR_NOTAVAIL;               /* No channel allocated for the transfer. */
  }
  else {
    if (DescriptorRecordPtr->Enabled) { /* Is channel enabled? */
      return ERR_NOTAVAIL;             /* If yes, channel descriptor can't be updated. */
    }
  }
  ChannelNumber = DescriptorRecordPtr->ChannelNumber;
  /* Source address */
  DescriptorPtr->SourceAddress = (LDD_DMA_TAddress)DMA_PDD_GetSourceAddress(DMA_BASE_PTR, ChannelNumber);
  /* Source address offset */
  DescriptorPtr->SourceAddressOffset = (LDD_DMA_TAddressOffset)DMA_PDD_GetSourceAddressOffset(DMA_BASE_PTR, ChannelNumber);
  /* Destination address */
  DescriptorPtr->DestinationAddress = (LDD_DMA_TAddress)DMA_PDD_GetDestinationAddress(DMA_BASE_PTR, ChannelNumber);
  /* Destination address offset */
  DescriptorPtr->DestinationAddressOffset = (LDD_DMA_TAddressOffset)DMA_PDD_GetDestinationAddressOffset(DMA_BASE_PTR, ChannelNumber);
  /* Transfer attributes: source transfer size, destination transfer size, source modulo, destination modulo */
  DescriptorPtr->SourceModuloSize = (LDD_DMA_TModuloSize)DMA_PDD_GetSourceAddressModulo(DMA_BASE_PTR, ChannelNumber);
  DescriptorPtr->SourceTransferSize = (LDD_DMA_TTransferSize)DMA_PDD_GetSourceDataTransferSize(DMA_BASE_PTR, ChannelNumber);
  DescriptorPtr->DestinationModuloSize = (LDD_DMA_TModuloSize)DMA_PDD_GetDestinationAddressModulo(DMA_BASE_PTR, ChannelNumber);
  DescriptorPtr->DestinationTransferSize = (LDD_DMA_TTransferSize)DMA_PDD_GetDestinationDataTransferSize(DMA_BASE_PTR, ChannelNumber);
  /* Minor loop byte count */
  DescriptorPtr->ByteCount = DMA_PDD_GetByteCount32(DMA_BASE_PTR, ChannelNumber);
  /* Major loop settings */
  if (DMA_PDD_GetCurrentMinorLoopLinkingEnabled(DMA_BASE_PTR, ChannelNumber) == 0x00U) {
    DescriptorPtr->InnerLoopChannelLink = FALSE;
    DescriptorPtr->OuterLoopCount = (LDD_DMA_TOuterLoopCount)DMA_PDD_GetCurrentMajorLoopCount15(DMA_BASE_PTR, ChannelNumber);
  }
  else {
    DescriptorPtr->InnerLoopChannelLink = TRUE;
    DescriptorPtr->InnerLoopLinkedChannel = (LDD_DMA_TChannelNumber)DMA_PDD_GetCurrentMinorLinkChannel(DMA_BASE_PTR, ChannelNumber);
    DescriptorPtr->OuterLoopCount = (LDD_DMA_TOuterLoopCount)DMA_PDD_GetCurrentMajorLoopCount9(DMA_BASE_PTR, ChannelNumber);
  }
  /* TCD's control and status register */
  DescriptorPtr->BandwidthControl = (LDD_DMA_TBandwidthControl)DMA_PDD_GetStallTime(DMA_BASE_PTR, ChannelNumber);
  if (DMA_PDD_GetMajorLoopLinkingEnabled(DMA_BASE_PTR, ChannelNumber) == 0x00U) {
    DescriptorPtr->OuterLoopChannelLink = FALSE;
  }
  else {
    DescriptorPtr->OuterLoopChannelLink = TRUE;
    DescriptorPtr->OuterLoopLinkedChannel = (LDD_DMA_TChannelNumber)DMA_PDD_GetMajorLinkChannel(DMA_BASE_PTR, ChannelNumber);
  }
  if (DMA_PDD_GetRequestAutoDisableEnabled(DMA_BASE_PTR, ChannelNumber) == 0x00U) {
    DescriptorPtr->DisableAfterRequest = FALSE;
  }
  else {
    DescriptorPtr->DisableAfterRequest = TRUE;
  }
  /* After transfer operation settings */
  if (DMA_PDD_GetScatterGatherEnabled(DMA_BASE_PTR, ChannelNumber) == 0x00U) {
    DescriptorPtr->AfterTransferComplete = LDD_DMA_ADDRESS_ADJUSTMENT;
    DescriptorPtr->SourceAddressAdjustment = (LDD_DMA_TAddressOffset)DMA_PDD_GetLastSourceAddressAdjustment(DMA_BASE_PTR, ChannelNumber);
    DescriptorPtr->DestinationAddressAdjustment = (LDD_DMA_TAddressOffset)DMA_PDD_GetLastDestinationAddressAdjustment_ScatterGather(DMA_BASE_PTR, ChannelNumber);
  }
  else {
    DescriptorPtr->AfterTransferComplete = LDD_DMA_SCATTER_GATHER;
    DescriptorPtr->ScatterGatherAddress = (LDD_DMA_TAddress)(DMA_PDD_GetLastDestinationAddressAdjustment_ScatterGather(DMA_BASE_PTR, ChannelNumber));
  }
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  InitChannel (component DMA_LDD)
**
**     Description :
**         The method initializes the DMA channel allocated for the DMA 
**         transfer defined by the transfer descriptor record input 
**         parameter DescriptorRecordPtr.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void InitChannel(DMA1_TDescriptorRecord *DescriptorRecordPtr)
{
  LDD_DMA_TTransferDescriptor *DescriptorPtr = DescriptorRecordPtr->DescriptorPtr;
  LDD_DMA_TChannelNumber ChannelNumber = DescriptorRecordPtr->ChannelNumber;

  DMA_PDD_ClearRequestEnable(DMA_BASE_PTR, DMA_PDD_ONE_CHANNEL, ChannelNumber); /* Disable channel HW requests. */
  DMA_PDD_ClearChannelActivityFlags(DMA_BASE_PTR, ChannelNumber, DMA_PDD_TRANSFER_DONE_FLAG); /* Clear DMA transfer done status flag. */
  /* Source address */
  DMA_PDD_SetSourceAddress(DMA_BASE_PTR, ChannelNumber, DescriptorPtr->SourceAddress);
  /* Source address offset */
  DMA_PDD_SetSourceAddressOffset(DMA_BASE_PTR, ChannelNumber, DescriptorPtr->SourceAddressOffset);
  /* Destination address */
  DMA_PDD_SetDestinationAddress(DMA_BASE_PTR, ChannelNumber, DescriptorPtr->DestinationAddress);
  /* Destination address offset */
  DMA_PDD_SetDestinationAddressOffset(DMA_BASE_PTR, ChannelNumber, DescriptorPtr->DestinationAddressOffset);
  /* Transfer attributes: source transfer size, destination transfer size, source modulo, destination modulo */
  DMA_PDD_SetSourceAddressModulo(DMA_BASE_PTR, ChannelNumber, DescriptorPtr->SourceModuloSize);
  DMA_PDD_SetSourceDataTransferSize(DMA_BASE_PTR, ChannelNumber, DescriptorPtr->SourceTransferSize);
  DMA_PDD_SetDestinationAddressModulo(DMA_BASE_PTR, ChannelNumber, DescriptorPtr->DestinationModuloSize);
  DMA_PDD_SetDestinationDataTransferSize(DMA_BASE_PTR, ChannelNumber, DescriptorPtr->DestinationTransferSize);
  /* Minor loop byte count */
  DMA_PDD_SetByteCount32(DMA_BASE_PTR, ChannelNumber, DescriptorPtr->ByteCount);
  /* Major loop settings */
  DMA_PDD_WriteCurrentMajorLoopCountReg(DMA_BASE_PTR, ChannelNumber, DescriptorPtr->OuterLoopCount); /* Major loop (transfers) count. */
  DMA_PDD_WriteBeginningMajorLoopCountReg(DMA_BASE_PTR, ChannelNumber, DescriptorPtr->OuterLoopCount); /* Major loop (transfers) count. */
  if (DescriptorPtr->InnerLoopChannelLink) { /* Minor loop linking enabled? */
    /* Minor loop linking settings */
    DMA_PDD_SetBeginningMinorLinkChannel(DMA_BASE_PTR, ChannelNumber, DescriptorPtr->InnerLoopLinkedChannel);
    DMA_PDD_EnableBeginningMinorLoopLinking(DMA_BASE_PTR, ChannelNumber, PDD_ENABLE);
    DMA_PDD_SetCurrentMinorLinkChannel(DMA_BASE_PTR, ChannelNumber, DescriptorPtr->InnerLoopLinkedChannel);
    DMA_PDD_EnableCurrentMinorLoopLinking(DMA_BASE_PTR, ChannelNumber, PDD_ENABLE);
  }
  /* TCD's control and status register */
  DMA_PDD_WriteControlStatusReg(DMA_BASE_PTR, ChannelNumber, 0U); /* Clear control status register. */
  DMA_PDD_SetStallTime(DMA_BASE_PTR, ChannelNumber, DescriptorPtr->BandwidthControl); /* Set stall time during transfer. */
  if (DescriptorPtr->OuterLoopChannelLink) { /* Channel linking after transfer complete enabled? */
    DMA_PDD_SetMajorLinkChannel(DMA_BASE_PTR, ChannelNumber, DescriptorPtr->OuterLoopLinkedChannel); /* Set linked channel number. */
    DMA_PDD_EnableMajorLoopLinking(DMA_BASE_PTR, ChannelNumber, PDD_ENABLE); /* Enable linking. */
  }
  if (DescriptorPtr->DisableAfterRequest) { /* Disable after request? */
    DMA_PDD_EnableRequestAutoDisable(DMA_BASE_PTR, ChannelNumber, PDD_ENABLE);
  }
  /* After transfer complete operation settings */
  if (DescriptorPtr->AfterTransferComplete == LDD_DMA_SCATTER_GATHER) {
    DMA_PDD_EnableScatterGather(DMA_BASE_PTR, ChannelNumber, PDD_ENABLE); /* Enable scatter/gather function. */
    DMA_PDD_SetLastSourceAddressAdjustment(DMA_BASE_PTR, ChannelNumber, 0U); /* Source address adjustment. */
    /* Scatter/gather address (address of next TCD) */
    DMA_PDD_SetLastDestinationAddressAdjustment_ScatterGather(DMA_BASE_PTR, ChannelNumber, DescriptorPtr->ScatterGatherAddress);
  }
  else {
    DMA_PDD_SetLastSourceAddressAdjustment(DMA_BASE_PTR, ChannelNumber, DescriptorPtr->SourceAddressAdjustment); /* Source address adjustment. */
    DMA_PDD_SetLastDestinationAddressAdjustment_ScatterGather(DMA_BASE_PTR, ChannelNumber, DescriptorPtr->DestinationAddressAdjustment); /* Destination address adjustment. */
  }
}

/*
** ===================================================================
**     Method      :  VerifyDescriptor (component DMA_LDD)
**
**     Description :
**         The method verifies a transfer descriptor of allocated channel 
**         defined by the pointer to its address. Returns TRUE if the 
**         channel's transfer descriptor is correct, FALSE if 
**         inconsistency is detected.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static bool VerifyDescriptor(LDD_DMA_TTransferDescriptor *DescriptorPtr)
{
  /* Store source transfer size byte divider mask */
  LDD_DMA_TTransferSize DividerMask = (LDD_DMA_TTransferSize)(0x01U << DescriptorPtr->SourceTransferSize) - 0x01U;

  /* Is minor loop byte count a multiple of the source transfer size? */
  if ((LDD_DMA_TTransferSize)(DescriptorPtr->ByteCount) & DividerMask) {
    return FALSE;                      /* If no, return. */
  }
  /* Is source address aligned to source transfer size? */
  if ((LDD_DMA_TTransferSize)(DescriptorPtr->SourceAddress) & DividerMask) {
    return FALSE;                      /* If no, return. */
  }
  /* Is source address offset aligned to source transfer size? */
  if ((LDD_DMA_TTransferSize)(DescriptorPtr->SourceAddressOffset) & DividerMask) {
    return FALSE;                      /* If no, return. */
  }
  /* Store destination transfer size byte divider mask */
  DividerMask = (LDD_DMA_TTransferSize)(0x01U << (DescriptorPtr->DestinationTransferSize)) - 0x01U;
  /* Is minor loop byte count a multiple of the destination transfer size? */
  if ((LDD_DMA_TTransferSize)(DescriptorPtr->ByteCount) & DividerMask) {
    return FALSE;                      /* If no, return. */
  }
  /* Is destination address aligned to destination transfer size? */
  if ((LDD_DMA_TTransferSize)(DescriptorPtr->DestinationAddress) & DividerMask) {
    return FALSE;                      /* If no, return. */
  }
  /* Is destination address offset aligned to destination transfer size? */
  if ((LDD_DMA_TTransferSize)(DescriptorPtr->DestinationAddressOffset) & DividerMask) {
    return FALSE;                      /* If no, return. */
  }
  return TRUE;                         /* Channel descriptor verified. */
}

/*
** ===================================================================
**     Method      :  GetChannelNumber (component DMA_LDD)
**
**     Description :
**         The method returns TRUE if some channel is allocated for the 
**         given descriptor, false if it is not. Number of allocated 
**         channel is returned indirectly into the ChannelNumber 
**         parameter.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static bool GetChannelNumber(LDD_TDeviceData *DeviceDataPtr, LDD_DMA_TTransferDescriptor *DescriptorPtr, LDD_DMA_TChannelNumber *ChannelNumber)
{
bool ChannelFound = FALSE;

  if (((DMA1_TDeviceData *)DeviceDataPtr)->ChannelRecord[DescriptorPtr->ChannelNumber]->DescriptorPtr == DescriptorPtr) {
    ChannelFound = TRUE;
    *ChannelNumber = DescriptorPtr->ChannelNumber; /* Save channel number. */
  }
  return ChannelFound;
}

/*
** ===================================================================
**     Method      :  GetRecord (component DMA_LDD)
**
**     Description :
**         The method returns TRUE if some channel is allocated for the 
**         given descriptor, false if it is not. Pointer to the 
**         descriptor record of allocated channel is returned indirectly 
**         into the DescriptorRecordPtr parameter.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static bool GetRecord(LDD_TDeviceData *DeviceDataPtr, LDD_DMA_TTransferDescriptor *DescriptorPtr, DMA1_TDescriptorRecordPtr *DescriptorRecordAddressPtr)
{
  bool RecordFound = FALSE;

  if (((DMA1_TDeviceData *)DeviceDataPtr)->ChannelRecord[DescriptorPtr->ChannelNumber]->DescriptorPtr == DescriptorPtr) {
    RecordFound = TRUE;
    *DescriptorRecordAddressPtr = ((DMA1_TDeviceData *)DeviceDataPtr)->ChannelRecord[DescriptorPtr->ChannelNumber]; /* Save descriptors record address. */
  }
  return RecordFound;
}

/* END DMA1. */

/*!
** @}
*/
/*
** ###################################################################
**
**     This file was created by Processor Expert 10.3 [05.09]
**     for the Freescale Kinetis series of microcontrollers.
**
** ###################################################################
*/
