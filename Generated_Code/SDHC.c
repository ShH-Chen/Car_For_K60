/* ###################################################################
**     THIS COMPONENT MODULE IS GENERATED BY THE TOOL. DO NOT MODIFY IT.
**     Filename    : SDHC.c
**     Project     : ProcessorExpert
**     Processor   : MK60FX512VLQ15
**     Component   : SDHC_LDD
**     Version     : Component 00.001, Driver 01.04, CPU db: 3.00.000
**     Compiler    : GNU C Compiler
**     Date/Time   : 2014-07-15, 17:57, # CodeGen: 103
**     Abstract    :
**          This component implements a SD host controller driver 
**          interface. Handles control and data transfers to/from
**          SD and MMC cards.
**     Settings    :
**          Component name                                 : SDHC
**          Device                                         : SDHC
**          Settings                                       : 
**            Interface                                    : 4-bit data mode
**            Bus clock                                    : 360.576923 kHz
**            Data timeout exponent                        : 27
**            DMA                                          : 
**              Read watermark                             : 8
**              Write watermark                            : 8
**            Buffers                                      : 
**              Transfer buffer table size                 : 8
**          Interrupt service/event                        : Enabled
**            SDHC                                         : INT_SDHC
**            SDHC priority                                : maximal priority
**          Pins                                           : 4-bit data mode
**            CLK pin                                      : ADC1_SE6a/PTE2/LLWU_P1/SPI1_SCK/UART1_CTS_b/SDHC0_DCLK
**            CLK pin signal                               : 
**            CMD pin                                      : ADC1_SE7a/PTE3/SPI1_SIN/UART1_RTS_b/SDHC0_CMD/SPI1_SOUT
**            CMD pin signal                               : 
**            Data                                         : 
**              DAT0 pin                                   : ADC1_SE5a/PTE1/LLWU_P0/SPI1_SOUT/UART1_RX/SDHC0_D0/I2C1_SCL/SPI1_SIN
**              DAT0 pin signal                            : 
**              DAT1                                       : Enabled
**                DAT1 pin                                 : ADC1_SE4a/PTE0/SPI1_PCS1/UART1_TX/SDHC0_D1/I2C1_SDA/RTC_CLKOUT
**                DAT1 pin signal                          : 
**              DAT2                                       : Enabled
**                DAT2 pin                                 : PTE5/SPI1_PCS2/UART3_RX/SDHC0_D2/FTM3_CH0
**                DAT2 pin signal                          : 
**              DAT3                                       : Enabled
**                DAT3 pin                                 : PTE4/LLWU_P2/SPI1_PCS0/UART3_TX/SDHC0_D3
**                DAT3 pin signal                          : 
**          Initialization                                 : 
**            Enable device                                : yes
**            Auto initialization                          : no
**            Event mask                                   : 
**              OnCardInserted                             : Enabled
**              OnCardRemoved                              : Enabled
**              OnFinished                                 : Enabled
**          CPU clock/configuration selection              : 
**            Clock configuration 0                        : This component enabled
**            Clock configuration 1                        : This component disabled
**            Clock configuration 2                        : This component disabled
**            Clock configuration 3                        : This component disabled
**            Clock configuration 4                        : This component disabled
**            Clock configuration 5                        : This component disabled
**            Clock configuration 6                        : This component disabled
**            Clock configuration 7                        : This component disabled
**     Contents    :
**         Init               - LDD_TDeviceData* SDHC_Init(LDD_TUserData *UserDataPtr);
**         Deinit             - void SDHC_Deinit(LDD_TDeviceData *DeviceDataPtr);
**         Enable             - LDD_TError SDHC_Enable(LDD_TDeviceData *DeviceDataPtr);
**         Disable            - LDD_TError SDHC_Disable(LDD_TDeviceData *DeviceDataPtr);
**         SetEventMask       - LDD_TError SDHC_SetEventMask(LDD_TDeviceData *DeviceDataPtr, LDD_TEventMask...
**         GetEventMask       - LDD_TEventMask SDHC_GetEventMask(LDD_TDeviceData *DeviceDataPtr);
**         DetectCards        - LDD_TError SDHC_DetectCards(LDD_TDeviceData *DeviceDataPtr);
**         SelectCard         - LDD_TError SDHC_SelectCard(LDD_TDeviceData *DeviceDataPtr, uint8_t Id);
**         GetCardInfo        - LDD_TError SDHC_GetCardInfo(LDD_TDeviceData *DeviceDataPtr,...
**         TransferBlocks     - LDD_TError SDHC_TransferBlocks(LDD_TDeviceData *DeviceDataPtr,...
**         EraseBlocks        - LDD_TError SDHC_EraseBlocks(LDD_TDeviceData *DeviceDataPtr, uint32_t Address,...
**         SetDataWidth       - LDD_TError SDHC_SetDataWidth(LDD_TDeviceData *DeviceDataPtr, uint8_t Width);
**         SelectBusClock     - LDD_TError SDHC_SelectBusClock(LDD_TDeviceData *DeviceDataPtr, SDHC_TBusClock...
**         SetVoltage         - LDD_TError SDHC_SetVoltage(LDD_TDeviceData *DeviceDataPtr, LDD_SDHC_TVoltage...
**         SetWriteProtection - LDD_TError SDHC_SetWriteProtection(LDD_TDeviceData *DeviceDataPtr,...
**         GetWriteProtection - LDD_TError SDHC_GetWriteProtection(LDD_TDeviceData *DeviceDataPtr, uint32_t...
**         CancelOperation    - LDD_TError SDHC_CancelOperation(LDD_TDeviceData *DeviceDataPtr);
**         GetStatus          - LDD_SDHC_TStatus SDHC_GetStatus(LDD_TDeviceData *DeviceDataPtr);
**         GetError           - LDD_SDHC_TError SDHC_GetError(LDD_TDeviceData *DeviceDataPtr, uint32_t...
**
**     Copyright : 1997 - 2014 Freescale Semiconductor, Inc. 
**     All Rights Reserved.
**     
**     Redistribution and use in source and binary forms, with or without modification,
**     are permitted provided that the following conditions are met:
**     
**     o Redistributions of source code must retain the above copyright notice, this list
**       of conditions and the following disclaimer.
**     
**     o Redistributions in binary form must reproduce the above copyright notice, this
**       list of conditions and the following disclaimer in the documentation and/or
**       other materials provided with the distribution.
**     
**     o Neither the name of Freescale Semiconductor, Inc. nor the names of its
**       contributors may be used to endorse or promote products derived from this
**       software without specific prior written permission.
**     
**     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
**     ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
**     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
**     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
**     ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
**     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
**     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
**     ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
**     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
**     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
**     
**     http: www.freescale.com
**     mail: support@freescale.com
** ###################################################################*/
/*!
** @file SDHC.c
** @version 01.04
** @brief
**          This component implements a SD host controller driver 
**          interface. Handles control and data transfers to/from
**          SD and MMC cards.
*/         
/*!
**  @addtogroup SDHC_module SDHC module documentation
**  @{
*/         

/* MODULE SDHC */

/*lint -save  -esym(960,10.1) -e961 Disable MISRA rule (10.1,12.1) checking. */

#include "Events.h"
#include "SDHC.h"
/* {Default RTOS Adapter} No RTOS includes */
#include "SDHC_PDD.h"
#include "PORT_PDD.h"

#ifdef __cplusplus
extern "C" {
#endif 

/* Configuration constants */
#define SDHC_MAX_CARD_NUMBER   1U
#define SDHC_BUFFER_TABLE_SIZE 8U

/* Component constants */
#define SDHC_OCR_HIGH_VOLTAGE_MASK     0x00FF8000UL
#define SDHC_OCR_LOW_VOLTAGE_MASK      0x00000080UL
#define SDHC_OCR_HIGH_CAPACITY_MASK    0x40000000UL
#define SDHC_IF_COND_LOW_VOLTAGE_MASK  0x00000200UL
#define SDHC_IF_COND_HIGH_VOLTAGE_MASK 0x00000100UL
#define SDHC_IF_COND_CHECK_PATTERN     0x000000AAUL
#define SDHC_VOLT_VALID_RETRY_COUNT    6500U /* Number of OCR (operation conditions register) request repetitions to give the card 1 second to power up (with 400kHz bus clock) */
#define SDHC_NO_RESPONSE               0U
#define SDHC_CSD_SIZE                  16U /* Card specific data register size */
#define SDHC_EXT_CSD_SIZE              512U /* Extended card specific data register size */
#define SDHC_SCR_SIZE                  8U /* SD card configuration register size */
#define SDHC_SFS_SIZE                  64U /* Switch function statuses register size */
#define SDHC_WRITE_PROTECT_MASK_SIZE   4U /* Write protection mask size */

/* Endianness correction macros */
#define SDHC_BE_TO_NE16(x) ((uint16_t)((uint16_t)(x) >> 8) | (uint16_t)((uint16_t)(x) << 8)) /* Big endian to native endian 16-bit */
#define SDHC_BE_TO_NE32(x) (((uint32_t)((uint32_t)(x) >> 24) & 0xFFU) | ((uint32_t)((uint32_t)(x) >> 8) & 0xFF00U) | ((uint32_t)((uint32_t)(x) << 8) & 0xFF0000U) | ((uint32_t)((uint32_t)(x) << 24) & 0xFF000000U)) /* Big endian to native endian 32-bit */
#define SDHC_NE_TO_BE16(x) ((uint16_t)((uint16_t)(x) >> 8) | (uint16_t)((uint16_t)(x) << 8)) /* Native endian to big endian 16-bit */
#define SDHC_NE_TO_BE32(x) (((uint32_t)((uint32_t)(x) >> 24) & 0xFFU) | ((uint32_t)((uint32_t)(x) >> 8) & 0xFF00U) | ((uint32_t)((uint32_t)(x) << 8) & 0xFF0000U) | ((uint32_t)((uint32_t)(x) << 24) & 0xFF000000U)) /* Native endian to big endian 32-bit */

/* Command arguments macros */
#define SDHC_CMD_ARG_RCA(RCA)            (uint32_t)((uint32_t)(RCA) << 16)
#define SDHC_SD_CMD6_ARG_MODE(Mode)      (uint32_t)((uint32_t)(Mode) << 31)
  #define SDHC_SD_CMD6_CHECK_FUNC  0U
  #define SDHC_SD_CMD6_SWITCH_FUNC 1U
#define SDHC_SD_CMD6_ARG_GROUP_1(Func)   (uint32_t)((uint32_t)(Func) << 0)
  #define SDHC_SD_CMD6_GROUP_1_HIGH_SPEED 1U
#define SDHC_SD_CMD6_ARG_GROUP_2(Func)   (uint32_t)((uint32_t)(Func) << 4)
#define SDHC_MMC_CMD6_ARG_ACCESS(Access) (uint32_t)((uint32_t)(Access) << 24)
  #define SDHC_MMC_CMD6_COMMAND_SET 0U
  #define SDHC_MMC_CMD6_SET_BITS    1U
  #define SDHC_MMC_CMD6_CLEAR_BITS  2U
  #define SDHC_MMC_CMD6_WRITE_BYTES 3U
#define SDHC_MMC_CMD6_ARG_INDEX(Index)   (uint32_t)((uint32_t)(Index) << 16)
#define SDHC_MMC_CMD6_ARG_VALUE(Value)   (uint32_t)((uint32_t)(Value) << 8)
#define SDHC_MMC_CMD6_ARG_CMD_SET(Set)   (uint32_t)((uint32_t)(Set) << 0)

/* Response 1 status register field access macros */
#define SDHC_R1_IS_ADDRESS_OUT_OF_RANGE(Response) ((Response)[0] & 0x80000000UL)
#define SDHC_R1_IS_ADDRESS_MISALIGN(Response)     ((Response)[0] & 0x40000000UL)
#define SDHC_R1_IS_BLOCK_LEN_ERROR(Response)      ((Response)[0] & 0x20000000UL)
#define SDHC_R1_IS_ERASE_SEQ_ERROR(Response)      ((Response)[0] & 0x10000000UL)
#define SDHC_R1_IS_ERASE_PARAM(Response)          ((Response)[0] & 0x08000000UL)
#define SDHC_R1_IS_WP_VIOLATION(Response)         ((Response)[0] & 0x04000000UL)
#define SDHC_R1_IS_CARD_IS_LOCKED(Response)       ((Response)[0] & 0x02000000UL)
#define SDHC_R1_IS_LOCK_UNLOCK_FAILED(Response)   ((Response)[0] & 0x01000000UL)
#define SDHC_R1_IS_COM_CRC_ERROR(Response)        ((Response)[0] & 0x00800000UL)
#define SDHC_R1_IS_ILLEGAL_COMMAND(Response)      ((Response)[0] & 0x00400000UL)
#define SDHC_R1_IS_CARD_ECC_FAILED(Response)      ((Response)[0] & 0x00200000UL)
#define SDHC_R1_IS_CC_ERROR(Response)             ((Response)[0] & 0x00100000UL)
#define SDHC_R1_IS_ERROR(Response)                ((Response)[0] & 0x00080000UL)
#define SDHC_R1_MMC_IS_UNDERRUN(Response)         ((Response)[0] & 0x00040000UL)
#define SDHC_R1_MMC_IS_OVERRUN(Response)          ((Response)[0] & 0x00020000UL)
#define SDHC_R1_IS_CSD_OVERWRITE(Response)        ((Response)[0] & 0x00010000UL)
#define SDHC_R1_IS_WP_ERASE_SKIP(Response)        ((Response)[0] & 0x00008000UL)
#define SDHC_R1_SD_IS_CARD_ECC_DISABLED(Response) ((Response)[0] & 0x00004000UL)
#define SDHC_R1_IS_ERASE_RESET(Response)          ((Response)[0] & 0x00002000UL)
#define SDHC_R1_GET_CURRENT_STATE(Response)       (((Response)[0] & 0x00001E00UL) >> 9)
  #define SDHC_R1_IDLE_STATE           0x00U
  #define SDHC_R1_READY_STATE          0x01U
  #define SDHC_R1_IDENTIFICATION_STATE 0x02U
  #define SDHC_R1_STAND_BY_STATE       0x03U
  #define SDHC_R1_TRANSFER_STATE       0x04U
  #define SDHC_R1_SENDING_DATA_STATE   0x05U
  #define SDHC_R1_RECEIVE_DATA_STATE   0x06U
  #define SDHC_R1_PROGRAMMING_STATE    0x07U
  #define SDHC_R1_DISCONNECT_STATE     0x08U
  #define SDHC_R1_BUS_TEST_STATE       0x09U
  #define SDHC_R1_SLEEP_STATE          0x0AU
#define SDHC_R1_IS_READY_FOR_DATA(Response)       ((Response)[0] & 0x00000100UL)
#define SDHC_R1_IS_SWITCH_ERROR(Response)         ((Response)[0] & 0x00000080UL)
#define SDHC_R1_IS_APP_CMD(Response)              ((Response)[0] & 0x00000020UL)
#define SDHC_R1_SD_IS_AKE_SEQ_ERROR(Response)     ((Response)[0] & 0x00000008UL)

/* Response 2 SD CSD (card specific data) v1, v2 and MMC CSD (card specific data) register field access macros */
#define SDHC_R2_GET_CSD_STRUCTURE(Response)        (((Response)[3] & 0x00C00000UL) >> 22)
  #define SDHC_SD_CSD_VERS_1_0         0U
  #define SDHC_SD_CSD_VERS_2_0         1U
  #define SDHC_MMC_CSD_VERS_1_0        0U
  #define SDHC_MMC_CSD_VERS_1_1        1U
  #define SDHC_MMC_CSD_VERS_1_2        2U
  #define SDHC_MMC_CSD_VERS_IN_EXT_CSD 3U
#define SDHC_R2_MMC_GET_SPEC_VERS(Response)        (((Response)[3] & 0x003C0000UL) >> 18)
  #define SDHC_MMC_CSD_SPEC_VERS_1_X 0U
  #define SDHC_MMC_CSD_SPEC_VERS_1_4 1U
  #define SDHC_MMC_CSD_SPEC_VERS_2_X 2U
  #define SDHC_MMC_CSD_SPEC_VERS_3_X 3U
  #define SDHC_MMC_CSD_SPEC_VERS_4_X 4U
#define SDHC_R2_GET_TAAC(Response)                 (((Response)[3] & 0x0000FF00UL) >> 8)
#define SDHC_R2_GET_NSAC(Response)                 (((Response)[3] & 0x000000FFUL) >> 0)
#define SDHC_R2_GET_TRAN_SPEED(Response)           (((Response)[2] & 0xFF000000UL) >> 24)
#define SDHC_R2_GET_CCC(Response)                  (((Response)[2] & 0x00FFF000UL) >> 12)
#define SDHC_R2_GET_READ_BL_LEN(Response)          (((Response)[2] & 0x00000F00UL) >> 8)
#define SDHC_R2_GET_READ_BL_PARTIAL(Response)      (((Response)[2] & 0x00000080UL) >> 7)
#define SDHC_R2_GET_WRITE_BLK_MISALIGN(Response)   (((Response)[2] & 0x00000040UL) >> 6)
#define SDHC_R2_GET_READ_BLK_MISALIGN(Response)    (((Response)[2] & 0x00000020UL) >> 5)
#define SDHC_R2_GET_DSR_IMP(Response)              (((Response)[2] & 0x00000010UL) >> 4)
/* Response 2 CSD (card specific data) v1 register field access macros */
#define SDHC_R2_CSD_V1_GET_C_SIZE(Response)         ((((Response)[2] & 0x00000003UL) << 10) | (((Response)[1] & 0xFFC00000UL) >> 22))
#define SDHC_R2_CSD_V1_GET_MIN_VDD_R_CURR(Response) (((Response)[1] & 0x00380000UL) >> 19)
#define SDHC_R2_CSD_V1_GET_MAX_VDD_R_CURR(Response) (((Response)[1] & 0x00070000UL) >> 16)
#define SDHC_R2_CSD_V1_GET_MIN_VDD_W_CURR(Response) (((Response)[1] & 0x0000E000UL) >> 13)
#define SDHC_R2_CSD_V1_GET_MAX_VDD_W_CURR(Response) (((Response)[1] & 0x00001C00UL) >> 10)
#define SDHC_R2_CSD_V1_GET_C_SIZE_MULT(Response)    (((Response)[1] & 0x00000380UL) >> 7)
/* Response 2 SD CSD (card specific data) v2 register field access macros */
#define SDHC_R2_CSD_V2_GET_C_SIZE(Response)         (((Response)[1] & 0x3FFFFF00UL) >> 8)
/* Response 2 SD CSD (card specific data) register field access macros */
#define SDHC_R2_SD_GET_ERASE_BLOCK_EN(Response)    (((Response)[1] & 0x00000040UL) >> 6)
#define SDHC_R2_SD_GET_SECTOR_SIZE(Response)       ((((Response)[1] & 0x0000003FUL) << 1) | (((Response)[0] & 0x80000000UL) >> 31))
#define SDHC_R2_SD_GET_WP_GRP_SIZE(Response)       (((Response)[0] & 0x1F000000UL) >> 24)
/* Response 2 MMC CSD (card specific data) register field access macros */
#define SDHC_R2_MMC_GET_ERASE_GRP_SIZE(Response)   (((Response)[1] & 0x0000007CUL) >> 2)
#define SDHC_R2_MMC_GET_ERASE_GRP_MULT(Response)   ((((Response)[1] & 0x00000003UL) << 3) | (((Response)[0] & 0xE0000000UL) >> 29))
#define SDHC_R2_MMC_GET_WP_GRP_SIZE(Response)      (((Response)[0] & 0x1F000000UL) >> 24)
/* Response 2 CSD (card specific data) register field access macros */
#define SDHC_R2_GET_WP_GRP_ENABLE(Response)        (((Response)[0] & 0x00800000UL) >> 23)
#define SDHC_R2_GET_DEFAULT_ECC(Response)          (((Response)[0] & 0x00600000UL) >> 21)
#define SDHC_R2_GET_R2W_FACTOR(Response)           (((Response)[0] & 0x001C0000UL) >> 18)
#define SDHC_R2_GET_WRITE_BL_LEN(Response)         (((Response)[0] & 0x0003C000UL) >> 14)
#define SDHC_R2_GET_WRITE_BL_PARTIAL(Response)     (((Response)[0] & 0x00002000UL) >> 13)
#define SDHC_R2_GET_CONTENT_PROT_APP(Response)     (((Response)[0] & 0x00000100UL) >> 8)
#define SDHC_R2_GET_FILE_FORMAT_GRP(Response)      (((Response)[0] & 0x00000080UL) >> 7)
#define SDHC_R2_GET_COPY(Response)                 (((Response)[0] & 0x00000040UL) >> 6)
#define SDHC_R2_GET_PERM_WRITE_PROTECT(Response)   (((Response)[0] & 0x00000020UL) >> 5)
#define SDHC_R2_GET_TMP_WRITE_PROTECT(Response)    (((Response)[0] & 0x00000010UL) >> 4)
#define SDHC_R2_GET_FILE_FORMAT(Response)          (((Response)[0] & 0x0000000CUL) >> 2)
#define SDHC_R2_GET_ECC(Response)                  (((Response)[0] & 0x00000003UL) >> 0)

/* Response 2 CSD (card specific data) register writable field masks */
#define SDHC_R2_FILE_FORMAT_GRP_MASK    0x00000080UL
#define SDHC_R2_COPY_MASK               0x00000040UL
#define SDHC_R2_PERM_WRITE_PROTECT_MASK 0x00000020UL
#define SDHC_R2_TMP_WRITE_PROTECT_MASK  0x00000010UL
#define SDHC_R2_FILE_FORMAT_MASK        0x0000000CUL
#define SDHC_R2_ECC_MASK                0x00000003UL

/* Response 2 CID register field access macros */
#define SDHC_R2_GET_MANUFACTURER_ID(Response)           (((Response)[3] & 0x00FF0000UL) >> 16)
/* Response 2 SD CID register field access macros */
#define SDHC_R2_SD_GET_OEM_APPLICATION_ID(Response)     (((Response)[3] & 0x0000FFFFUL) >> 0)
#define SDHC_R2_SD_GET_PRODUCT_NAME(Response)           ((((Response)[2] & 0xFFFFFFFFUL) << 8) | (((Response)[1] & 0xFF000000UL) >> 24))
#define SDHC_R2_SD_GET_PRODUCT_REVISION(Response)       (((Response)[1] & 0x00FF0000UL) >> 16)
#define SDHC_R2_SD_GET_PRODUCT_SERIAL_NUMBER(Response)  ((((Response)[1] & 0x0000FFFFUL) << 16) | (((Response)[0] & 0xFFFF0000UL) >> 16))
#define SDHC_R2_SD_GET_MANUFACTURING_DATE(Response)     (((Response)[0] & 0x00000FFFUL) >> 0)
/* Response 2 MMC CID register field access macros */
#define SDHC_R2_MMC_GET_CARD_BGA(Response)              (((Response)[3] & 0x00000300UL) >> 8)
#define SDHC_R2_MMC_GET_OEM_APPLICATION_ID(Response)    (((Response)[3] & 0x000000FFUL) >> 0)
#define SDHC_R2_MMC_GET_PRODUCT_NAME(Response)          ((((Response)[2] & 0xFFFFFFFFUL) << 16) | (((Response)[1] & 0xFFFF0000UL) >> 16))
#define SDHC_R2_MMC_GET_PRODUCT_REVISION(Response)      (((Response)[1] & 0x0000FF00UL) >> 8)
#define SDHC_R2_MMC_GET_PRODUCT_SERIAL_NUMBER(Response) ((((Response)[1] & 0x000000FFUL) << 24) | (((Response)[0] & 0xFFFFFF00UL) >> 8))
#define SDHC_R2_MMC_GET_MANUFACTURING_DATE(Response)    (((Response)[0] & 0x000000FFUL) >> 0)

/* Response 3 OCR (operation conditions register) access macros */
#define SDHC_R3_OCR_IS_CARD_POWER_UP(Response)      ((Response)[0] & 0x80000000UL)
#define SDHC_R3_OCR_IS_CARD_HIGH_CAPACITY(Response) ((Response)[0] & 0x40000000UL)

/* Response 6 field access macros */
#define SDHC_R6_GET_RCA(Response) ((Response)[0] >> 16)

/* Extended CSD (card specific data) register data block field indices */
#define SDHC_EXT_CSD_S_CMD_SET_INDEX                   504U
#define SDHC_EXT_CSD_INI_TIMEOUT_AP_INDEX              241U
#define SDHC_EXT_CSD_PWR_CL_DDR_52_360_INDEX           239U
#define SDHC_EXT_CSD_PWR_CL_DDR_52_195_INDEX           238U
#define SDHC_EXT_CSD_MIN_PERF_DDR_W_8_52_INDEX         235U
#define SDHC_EXT_CSD_MIN_PERF_DDR_R_8_52_INDEX         234U
#define SDHC_EXT_CSD_TRIM_MULT_INDEX                   232U
#define SDHC_EXT_CSD_SEC_FEATURE_SUPPORT_INDEX         231U
#define SDHC_EXT_CSD_SEC_ERASE_MULT_INDEX              230U
#define SDHC_EXT_CSD_SEC_TRIM_MULT_INDEX               229U
#define SDHC_EXT_CSD_BOOT_INFO_INDEX                   228U
#define SDHC_EXT_CSD_BOOT_SIZE_MULTI_INDEX             226U
#define SDHC_EXT_CSD_ACC_SIZE_INDEX                    225U
#define SDHC_EXT_CSD_HC_ERASE_GRP_SIZE_INDEX           224U
#define SDHC_EXT_CSD_ERASE_TIMEOUT_MULT_INDEX          223U
#define SDHC_EXT_CSD_REL_WR_SEC_C_INDEX                222U
#define SDHC_EXT_CSD_HC_WP_GRP_SIZE_INDEX              221U
#define SDHC_EXT_CSD_S_C_VCC_INDEX                     220U
#define SDHC_EXT_CSD_S_C_VCCQ_INDEX                    219U
#define SDHC_EXT_CSD_S_A_TIMEOUT_INDEX                 217U
#define SDHC_EXT_CSD_SEC_COUNT_INDEX                   212U
#define SDHC_EXT_CSD_MIN_PERF_W_8_52_INDEX             210U
#define SDHC_EXT_CSD_MIN_PERF_R_8_52_INDEX             209U
#define SDHC_EXT_CSD_MIN_PERF_W_8_26_4_52_INDEX        208U
#define SDHC_EXT_CSD_MIN_PERF_R_8_26_4_52_INDEX        207U
#define SDHC_EXT_CSD_MIN_PERF_W_4_26_INDEX             206U
#define SDHC_EXT_CSD_MIN_PERF_R_4_26_INDEX             205U
#define SDHC_EXT_CSD_PWR_CL_26_360_INDEX               203U
#define SDHC_EXT_CSD_PWR_CL_52_360_INDEX               202U
#define SDHC_EXT_CSD_PWR_CL_26_195_INDEX               201U
#define SDHC_EXT_CSD_PWR_CL_52_195_INDEX               200U
#define SDHC_EXT_CSD_CARD_TYPE_INDEX                   196U
#define SDHC_EXT_CSD_CSD_STRUCTURE_INDEX               194U
#define SDHC_EXT_CSD_EXT_CSD_REV_INDEX                 192U
#define SDHC_EXT_CSD_CMD_SET_INDEX                     191U
#define SDHC_EXT_CSD_CMD_SET_REV_INDEX                 189U
#define SDHC_EXT_CSD_POWER_CLASS_INDEX                 187U
#define SDHC_EXT_CSD_HS_TIMING_INDEX                   185U
#define SDHC_EXT_CSD_BUS_WIDTH_INDEX                   183U
#define SDHC_EXT_CSD_ERASED_MEM_CONT_INDEX             181U
#define SDHC_EXT_CSD_PARTITION_CONFIG_INDEX            179U
#define SDHC_EXT_CSD_BOOT_CONFIG_PROT_INDEX            178U
#define SDHC_EXT_CSD_BOOT_BUS_WIDTH_INDEX              177U
#define SDHC_EXT_CSD_ERASE_GROUP_DEF_INDEX             175U
#define SDHC_EXT_CSD_BOOT_WP_INDEX                     173U
#define SDHC_EXT_CSD_USER_WP_INDEX                     171U
#define SDHC_EXT_CSD_FW_CONFIG_INDEX                   169U
#define SDHC_EXT_CSD_RPMB_SIZE_MULT_INDEX              168U
#define SDHC_EXT_CSD_RST_N_FUNCTION_INDEX              162U
#define SDHC_EXT_CSD_PARTITIONING_SUPPORT_INDEX        160U
#define SDHC_EXT_CSD_MAX_ENH_SIZE_MULT_INDEX           157U
#define SDHC_EXT_CSD_PARTITIONS_ATTRIBUTE_INDEX        156U
#define SDHC_EXT_CSD_PARTITION_SETTING_COMPLETED_INDEX 155U
#define SDHC_EXT_CSD_GP_SIZE_MULT_1_0_INDEX            154U
#define SDHC_EXT_CSD_GP_SIZE_MULT_1_1_INDEX            153U
#define SDHC_EXT_CSD_GP_SIZE_MULT_1_2_INDEX            152U
#define SDHC_EXT_CSD_GP_SIZE_MULT_2_0_INDEX            151U
#define SDHC_EXT_CSD_GP_SIZE_MULT_2_1_INDEX            150U
#define SDHC_EXT_CSD_GP_SIZE_MULT_2_2_INDEX            149U
#define SDHC_EXT_CSD_GP_SIZE_MULT_3_0_INDEX            148U
#define SDHC_EXT_CSD_GP_SIZE_MULT_3_1_INDEX            147U
#define SDHC_EXT_CSD_GP_SIZE_MULT_3_2_INDEX            146U
#define SDHC_EXT_CSD_GP_SIZE_MULT_4_0_INDEX            145U
#define SDHC_EXT_CSD_GP_SIZE_MULT_4_1_INDEX            144U
#define SDHC_EXT_CSD_GP_SIZE_MULT_4_2_INDEX            143U
#define SDHC_EXT_CSD_ENH_SIZE_MULT_INDEX               140U
#define SDHC_EXT_CSD_ENH_START_ADDR_INDEX              136U
#define SDHC_EXT_CSD_SEC_BAD_BLK_MGMNT_INDEX           134U

/* SCR (SD card configuration register) data block field access macros */
#define SDHC_SCR_GET_SCR_STRUCTURE(Response)         ((((uint8_t*)(Response))[0] & 0xF0U) >> 4)
#define SDHC_SCR_GET_SD_SPEC(Response)               ((((uint8_t*)(Response))[0] & 0x0FU) >> 0)
  #define SDHC_SCR_SD_SPEC_VERS_1_0X 0U
  #define SDHC_SCR_SD_SPEC_VERS_1_10 1U
  #define SDHC_SCR_SD_SPEC_VERS_2_00 2U
#define SDHC_SCR_GET_DATA_STAT_AFTER_ERASE(Response) ((((uint8_t*)(Response))[1] & 0x80U) >> 7)
#define SDHC_SCR_GET_SD_SECURITY(Response)           ((((uint8_t*)(Response))[1] & 0x70U) >> 4)
#define SDHC_SCR_GET_SD_BUS_WIDTHS(Response)         ((((uint8_t*)(Response))[1] & 0x0FU) >> 0)
  #define SDHC_SCR_SD_BUS_WIDTH_1_BIT_MASK 0x01U
  #define SDHC_SCR_SD_BUS_WIDTH_4_BIT_MASK 0x04U

/* Switch function status block position in the component's card data structure info block */
#define SDHC_SFS_BLOCK_START 8U
/* Switch function status block field access macros */
#define SDHC_SFS_IS_FUNC_SUPPORTED(Response, Group, Index) ((SDHC_BE_TO_NE16(((uint16_t*)(Response))[6U - ((Group) - 1U)]) >> (Index)) & 1U)
  #define SDHC_SFS_HIGH_SPEED_FUNC_GROUP 1U
  #define SDHC_SFS_HIGH_SPEED_FUNC_INDEX 1U

/* Voltage validation substates */
#define SDHC_VV_START      0U
#define SDHC_VV_SDHC_CHECK 1U
#define SDHC_VV_SD_CHECK   2U
#define SDHC_VV_MMC_CHECK  3U
#define SDHC_VV_FINISH     4U

/* Card registration substates */
#define SDHC_CR_START   0U
#define SDHC_CR_GET_CID 1U
#define SDHC_CR_GET_RCA 2U
#define SDHC_CR_FINISH  3U

/* Card info retrieval substates */
#define SDHC_CIR_START                0U
#define SDHC_CIR_STAND_BY_STATE       1U
#define SDHC_CIR_GET_CSD              2U
#define SDHC_CIR_TRANSFER_STATE       3U
#define SDHC_CIR_GET_EXT_CSD          4U
#define SDHC_CIR_BUS_TEST_4_BIT_WRITE 5U
#define SDHC_CIR_BUS_TEST_4_BIT_READ  6U
#define SDHC_CIR_BUS_TEST_8_BIT_WRITE 7U
#define SDHC_CIR_BUS_TEST_8_BIT_READ  8U
#define SDHC_CIR_GET_SCR              9U
#define SDHC_CIR_GET_FUNC_STATUS      10U
#define SDHC_CIR_FINISH               11U

/* Blocks erasion substates */
#define SDHC_E_SET_START 0U
#define SDHC_E_SET_END   1U
#define SDHC_E_EXECUTE   2U
#define SDHC_E_FINISH    3U

/* Data width selection substates */
#define SDHC_DWS_START  0U
#define SDHC_DWS_BUSY   1U
#define SDHC_DWS_FINISH 2U

/* Command states */
#define SDHC_CMD_DATA_LEN 0U
#define SDHC_CMD_START    1U
#define SDHC_CMD_ACMD     2U
#define SDHC_CMD_FINISH   3U
#define SDHC_CMD_DATA     4U
#define SDHC_CMD_ERROR    5U

typedef enum {
  SDHC_IDLE = 0,
  SDHC_READY = 1,
  SDHC_IDENT = 2,
  SDHC_STAND_BY = 3,
  SDHC_TRANSFER = 4,
  SDHC_SENDING = 5,
  SDHC_RECEIVE = 6,
  SDHC_PROGRAMMING = 7,
  SDHC_DISCONNECT = 8,
  SDHC_BUS_TEST = 9,
  SDHC_SLEEP = 10
} SDHC_TCardState;

typedef struct {
  bool               Initialized;      /* Indicates if the structure contains valid card data */
  LDD_SDHC_TCardType Type;             /* Card type (see SDHC_TCardType) */
  uint32_t           CID[4];           /* Card ID (from the card) */
  uint16_t           RCA;              /* Relative card address */
  uint32_t           CSD[4];           /* The CSD (card specific data) register value retrieved from the card */
  uint8_t            Block[512];       /* The extended CSD (card specific data) or SCR (SD card configuration register) value retrieved from the card */
  uint8_t            DataWidths;       /* Data widths succeeded in bus test */
  bool               HighCapacity;     /* Indicates block addressing requirement */
} SDHC_TCardInfo;

/* ADMA2 transfer buffer descriptor attribute constants */
#define SDHC_ADMA2_VALID         0x0001U /* Descriptor line is valid */
#define SDHC_ADMA2_END           0x0002U /* Descriptor line is ending */
#define SDHC_ADMA2_INT           0x0004U /* Generate interrupt when the descriptor is done*/
#define SDHC_ADMA2_ATTR_ACT_NOP  0x0000U /* No operation */
#define SDHC_ADMA2_ATTR_ACT_RSV  0x0010U /* Reserved (no operation) */
#define SDHC_ADMA2_ATTR_ACT_TRAN 0x0020U /* Transfer data with address and length set in this descriptor line */
#define SDHC_ADMA2_ATTR_ACT_LINK 0x0030U /* Link to another descriptor */
#define SDHC_SINGLE_BLOCK_TRANS_ATTRS (SDHC_ADMA2_VALID | SDHC_ADMA2_END | SDHC_ADMA2_ATTR_ACT_TRAN)

typedef struct {
  uint16_t Attributes;                 /* Transfer buffer attributes */
  uint16_t Length;                     /* Transfer buffer data length */
  uint32_t Address;                    /* Transfer buffer data address */
} SDHC_TTransferBufferDesc;

#define SDHC_TRANSFER_TABLE_ALIGN  4U  /* Transfer table memory alignment */
#define SDHC_TRANSFER_BUFFER_ALIGN 4U  /* Transfer buffer memory alignment */

/* Pins port register bit indices where to configure pulls */
#define SDHC_PIN_CMD_PORT_INDEX  3U
#define SDHC_PIN_DAT0_PORT_INDEX 1U
#define SDHC_PIN_DAT1_PORT_INDEX 0U
#define SDHC_PIN_DAT2_PORT_INDEX 5U
#define SDHC_PIN_DAT3_PORT_INDEX 4U

typedef struct {
  bool               Enabled;          /* Indicates whether the device is enabled */
  LDD_TUserData      *UserDataPtr;     /* User data structure pointer */
  LDD_TEventMask     EventMask;        /* Event mask used for run-time enabling and disabling of events */
  LDD_SDHC_TStatus   State;            /* Main state of the component */
  uint8_t            Substate;         /* Substate of main state */
  uint8_t            CmdState;         /* Card command state */
  uint8_t            CardId;           /* Card ID of the selected card */
  uint8_t            NewCardId;        /* Card ID actually registered during card registration */
  LDD_SDHC_TCardType CardType;         /* Card type actually identified during voltage validation or the type of the selected card */
  bool               HighCapacity;     /* High capacity card indication. Needed for special initialization of SDHC cards. */
  SDHC_TCardState    CardState;        /* State of the selected card */
  bool               HighVoltage;      /* Indicates whether high bus voltage is currently set */
  uint32_t           CardsVoltages;    /* Mask of voltages supported by all cards */
  uint16_t           RetryCounter;     /* Counter for command timeout until give up */
  SDHC_TCardInfo     Cards[SDHC_MAX_CARD_NUMBER]; /* Card data structures list */
  LDD_SDHC_TError    LastError;        /* The last error that has occurred during a card operation */
  uint32_t           LastErrorAddress; /* Card memory address of the last correctly accessed location before an error has occurred */
  uint8_t            TransferTableMem[(SDHC_BUFFER_TABLE_SIZE * sizeof(SDHC_TTransferBufferDesc)) + SDHC_TRANSFER_TABLE_ALIGN]; /* Memory for the transfer buffer descriptors table */
  SDHC_TTransferBufferDesc *TransferTable; /* Pointer to the transfer buffer descriptors table */
  uint32_t           TransferBlockSize; /* Size of buffers to transfer */
  uint32_t           TransferBlockCount; /* Number of buffers to transfer */
  LDD_SDHC_TCardInfo *CardInfoPtr;     /* Card info structure pointer where to store the result of the GetCardInfo method call */
  LDD_SDHC_TWriteProtectType WriteProtType; /* Write protection type to set */
  uint32_t           *WriteProtMaskPtr; /* Write protection mask pointer where to store the result of the GetWriteProtection method call */
  bool               WriteProtFlag;    /* Write protection flag value to be set */
  LDD_SDHC_TTransferOperation TransferOperation; /* Ongoing transfer operation */
  uint32_t           Address;          /* Card memory address used in an ongoing operation */
  uint8_t            CSDMem[SDHC_CSD_SIZE + SDHC_TRANSFER_BUFFER_ALIGN]; /* Buffer for card CSD (card specific data) register programming */
  uint8_t            *CSDPtr;          /* Aligned CSD (card specific data) register buffer pointer */
  uint8_t            BusTestMem[8U + SDHC_TRANSFER_BUFFER_ALIGN]; /* Bus test result buffer for MMC cards */
  uint8_t            *BusTestPtr;      /* Aligned pointer to bus test result */
  uint8_t            DataWidth;        /* Communication data width currently set */
  SDHC_TBusClock     Frequency;        /* Bus clock frequency currently set */
  uint32_t           ErasionStart;     /* Start address of the erased memory range */
  uint32_t           ErasionEnd;       /* End address of the erased memory range */
  bool               Cancel;           /* Indicates ongoing operation cancelation */
  LDD_TClockConfiguration SpeedMode;   /* Clock configuration currently set */
  bool               EnabledMode;      /* Indicates whether the device is enabled in the current clock configuration */
} SDHC_TDeviceData;

/* {Default RTOS Adapter} Static object used for simulation of dynamic driver memory allocation */
static SDHC_TDeviceData DeviceDataPrv__DEFAULT_RTOS_ALLOC;
/* {Default RTOS Adapter} Global variable used for passing a parameter into ISR */
static SDHC_TDeviceData* INT_SDHC__DEFAULT_RTOS_ISRPARAM;

/* Internal method prototypes */
static void VoltageValidation(LDD_TDeviceData *DeviceDataPtr, uint32_t Flags, uint32_t *Response);
static void CardRegistration(LDD_TDeviceData *DeviceDataPtr, uint32_t Flags, uint32_t *Response);
static void CardInfoRetrieval(LDD_TDeviceData *DeviceDataPtr, uint32_t Flags, uint32_t *Response);
static bool CardSelection(LDD_TDeviceData *DeviceDataPtr, uint32_t Flags, uint32_t *Response);
static bool Transfer(LDD_TDeviceData *DeviceDataPtr, uint32_t Flags, uint32_t *Response);
static bool Erasion(LDD_TDeviceData *DeviceDataPtr, uint32_t Flags, uint32_t *Response);
static bool DataWidthSelection(LDD_TDeviceData *DeviceDataPtr, uint32_t Flags, uint32_t *Response);
static bool BusClockSelection(LDD_TDeviceData *DeviceDataPtr, uint32_t Flags, uint32_t *Response);
static bool WriteProtectionSetup(LDD_TDeviceData *DeviceDataPtr, uint32_t Flags, uint32_t *Response);
static bool WriteProtectionRetrieval(LDD_TDeviceData *DeviceDataPtr, uint32_t Flags, uint32_t *Response);
static void SetBusClockPrescalers(LDD_TDeviceData *DeviceDataPtr, SDHC_TBusClock Frequency);
static LDD_SDHC_TError GetCommandError(LDD_TDeviceData *DeviceDataPtr, uint32_t Flags, uint32_t *Response);
static void SendCardStatusRequest(LDD_TDeviceData *DeviceDataPtr);
static void EventHandler(LDD_TDeviceData *DeviceDataPtr);

/*
** ===================================================================
**     Method      :  SDHC_Init (component SDHC_LDD)
*/
/*!
**     @brief
**         Initializes the device. Allocates memory for the device data
**         structure, allocates interrupt vectors and sets interrupt
**         priority, sets pin routing, sets timing, etc. If the
**         property <"Enable device"> is set to "yes" then the device
**         is also enabled (see the description of the <Enable> method).
**         In this case the <Enable> method is not necessary and need
**         not to be generated. This method can be called only once.
**         Before the second call of Init the <Deinit> method must be
**         called first.
**     @param
**         UserDataPtr     - Pointer to user data
**                           structure pointer.
**     @return
**                         - Pointer to the device data structure. 
*/
/* ===================================================================*/
LDD_TDeviceData* SDHC_Init(LDD_TUserData *UserDataPtr)
{
  SDHC_TDeviceData *DeviceDataPrv;
  uint8_t Id;
  /* {Default RTOS Adapter} Driver memory allocation: Dynamic allocation is simulated by a pointer to the static object */
  DeviceDataPrv = &DeviceDataPrv__DEFAULT_RTOS_ALLOC;

  /* Initialize the device data */
  DeviceDataPrv->UserDataPtr = UserDataPtr; /* Store the user data pointer */
  DeviceDataPrv->CardId = SDHC_NO_CARD; /* No card will be selected */
  DeviceDataPrv->State = LDD_SDHC_RESET; /* Cards will be reseted after host initialization */
  DeviceDataPrv->HighVoltage = TRUE;   /* Initially set bus voltage to high */
  DeviceDataPrv->LastError = LDD_SDHC_ERR_OK; /* Clear the error code */
  for (Id = 0; Id < SDHC_MAX_CARD_NUMBER; Id++) {
    DeviceDataPrv->Cards[Id].Initialized = FALSE;
  }
  DeviceDataPrv->TransferTable = (SDHC_TTransferBufferDesc*) /* Align transfer buffer table memory according to hardware requirements */
    (((uint32_t)DeviceDataPrv->TransferTableMem + SDHC_TRANSFER_TABLE_ALIGN) & (uint32_t)(~(uint32_t)(SDHC_TRANSFER_TABLE_ALIGN - 1U)));
  DeviceDataPrv->CSDPtr = (uint8_t*)   /* Align CSD (card specific data) card register buffer according to hardware requirements */
    (((uint32_t)DeviceDataPrv->CSDMem + SDHC_TRANSFER_BUFFER_ALIGN) & (uint32_t)(~(uint32_t)(SDHC_TRANSFER_BUFFER_ALIGN - 1U)));
  DeviceDataPrv->BusTestPtr = (uint8_t*) /* Align bus test buffer according to hardware requirements */
    (((uint32_t)DeviceDataPrv->BusTestMem + SDHC_TRANSFER_BUFFER_ALIGN) & (uint32_t)(~(uint32_t)(SDHC_TRANSFER_BUFFER_ALIGN - 1U)));
  DeviceDataPrv->DataWidth = LDD_SDHC_CARD_DATA_WIDTH_1_BIT; /* Set default data width */
  DeviceDataPrv->Cancel = FALSE;       /* Clear the cancel flag */
  DeviceDataPrv->SpeedMode = CPU_CLOCK_CONFIG_0; /* Set initial clock configuration */
  DeviceDataPrv->EventMask =           /* Initialize the event mask */
    LDD_SDHC_ON_CARD_INSERTED |
    LDD_SDHC_ON_CARD_REMOVED |
    LDD_SDHC_ON_FINISHED | 0U;
  DeviceDataPrv->EnabledMode = TRUE;   /* Enable the device clock configuration */
  /* SIM_SCGC3: ESDHC=1 */
  SIM_SCGC3 |= SIM_SCGC3_ESDHC_MASK;
  /* Set pin assignments */
  /* PORTE_PCR2: ISF=0,MUX=4 */
  PORTE_PCR2 = (uint32_t)((PORTE_PCR2 & (uint32_t)~(uint32_t)(
                PORT_PCR_ISF_MASK |
                PORT_PCR_MUX(0x03)
               )) | (uint32_t)(
                PORT_PCR_MUX(0x04)
               ));
  /* PORTE_PCR3: ISF=0,MUX=4 */
  PORTE_PCR3 = (uint32_t)((PORTE_PCR3 & (uint32_t)~(uint32_t)(
                PORT_PCR_ISF_MASK |
                PORT_PCR_MUX(0x03)
               )) | (uint32_t)(
                PORT_PCR_MUX(0x04)
               ));
  /* Enable and set pull-up on command pin */
  PORT_PDD_SetPinPullSelect(PORTE_BASE_PTR, SDHC_PIN_CMD_PORT_INDEX, PORT_PDD_PULL_UP);
  PORT_PDD_SetPinPullEnable(PORTE_BASE_PTR, SDHC_PIN_CMD_PORT_INDEX, PORT_PDD_PULL_ENABLE);
  PORT_PDD_SetPinDriveStrength(PORTE_BASE_PTR, SDHC_PIN_CMD_PORT_INDEX, PORT_PDD_DRIVE_STRENGTH_HIGH);
  /* PORTE_PCR1: ISF=0,MUX=4 */
  PORTE_PCR1 = (uint32_t)((PORTE_PCR1 & (uint32_t)~(uint32_t)(
                PORT_PCR_ISF_MASK |
                PORT_PCR_MUX(0x03)
               )) | (uint32_t)(
                PORT_PCR_MUX(0x04)
               ));
  /* Enable and set pull-up on data pins */
  PORT_PDD_SetPinPullSelect(PORTE_BASE_PTR, SDHC_PIN_DAT0_PORT_INDEX, PORT_PDD_PULL_UP);
  PORT_PDD_SetPinPullEnable(PORTE_BASE_PTR, SDHC_PIN_DAT0_PORT_INDEX, PORT_PDD_PULL_ENABLE);
  PORT_PDD_SetPinDriveStrength(PORTE_BASE_PTR, SDHC_PIN_DAT0_PORT_INDEX, PORT_PDD_DRIVE_STRENGTH_HIGH);
  /* PORTE_PCR0: ISF=0,MUX=4 */
  PORTE_PCR0 = (uint32_t)((PORTE_PCR0 & (uint32_t)~(uint32_t)(
                PORT_PCR_ISF_MASK |
                PORT_PCR_MUX(0x03)
               )) | (uint32_t)(
                PORT_PCR_MUX(0x04)
               ));
  /* Enable and set pull-up on data pins */
  PORT_PDD_SetPinPullSelect(PORTE_BASE_PTR, SDHC_PIN_DAT1_PORT_INDEX, PORT_PDD_PULL_UP);
  PORT_PDD_SetPinPullEnable(PORTE_BASE_PTR, SDHC_PIN_DAT1_PORT_INDEX, PORT_PDD_PULL_ENABLE);
  PORT_PDD_SetPinDriveStrength(PORTE_BASE_PTR, SDHC_PIN_DAT1_PORT_INDEX, PORT_PDD_DRIVE_STRENGTH_HIGH);
  /* PORTE_PCR5: ISF=0,MUX=4 */
  PORTE_PCR5 = (uint32_t)((PORTE_PCR5 & (uint32_t)~(uint32_t)(
                PORT_PCR_ISF_MASK |
                PORT_PCR_MUX(0x03)
               )) | (uint32_t)(
                PORT_PCR_MUX(0x04)
               ));
  /* Enable and set pull-up on data pins */
  PORT_PDD_SetPinPullSelect(PORTE_BASE_PTR, SDHC_PIN_DAT2_PORT_INDEX, PORT_PDD_PULL_UP);
  PORT_PDD_SetPinPullEnable(PORTE_BASE_PTR, SDHC_PIN_DAT2_PORT_INDEX, PORT_PDD_PULL_ENABLE);
  PORT_PDD_SetPinDriveStrength(PORTE_BASE_PTR, SDHC_PIN_DAT2_PORT_INDEX, PORT_PDD_DRIVE_STRENGTH_HIGH);
  /* PORTE_PCR4: ISF=0,MUX=4 */
  PORTE_PCR4 = (uint32_t)((PORTE_PCR4 & (uint32_t)~(uint32_t)(
                PORT_PCR_ISF_MASK |
                PORT_PCR_MUX(0x03)
               )) | (uint32_t)(
                PORT_PCR_MUX(0x04)
               ));
  /* Enable and set pull-up on data pins */
  PORT_PDD_SetPinPullSelect(PORTE_BASE_PTR, SDHC_PIN_DAT3_PORT_INDEX, PORT_PDD_PULL_UP);
  PORT_PDD_SetPinPullEnable(PORTE_BASE_PTR, SDHC_PIN_DAT3_PORT_INDEX, PORT_PDD_PULL_ENABLE);
  PORT_PDD_SetPinDriveStrength(PORTE_BASE_PTR, SDHC_PIN_DAT3_PORT_INDEX, PORT_PDD_DRIVE_STRENGTH_HIGH);
  /* Configure card detection and DMA mode */
  /* SDHC_PROCTL: ??=0,??=0,??=0,??=0,??=0,WECRM=0,WECINS=0,WECINT=0,??=0,??=0,??=0,??=0,IABG=0,RWCTL=0,CREQ=0,SABGREQ=0,??=0,??=0,??=0,??=0,??=0,??=0,DMAS=2,CDSS=0,CDTL=0,EMODE=2,D3CD=0,DTW=0,LCTL=0 */
  SDHC_PROCTL = SDHC_PROCTL_DMAS(0x02) |
                SDHC_PROCTL_EMODE(0x02) |
                SDHC_PROCTL_DTW(0x00);
  /* Set DMA watermark levels */
  /* SDHC_WML: ??=0,??=0,??=0,WRBRSTLEN=0,WRWML=8,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,RDWML=8 */
  SDHC_WML = SDHC_WML_WRBRSTLEN(0x00) |
             SDHC_WML_WRWML(0x08) |
             SDHC_WML_RDWML(0x08);
  /* SDHC_VENDOR: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,INTSTVAL=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,EXBLKNU=0,EXTDMAEN=0 */
  SDHC_VENDOR = SDHC_VENDOR_INTSTVAL(0x00);
  /* SIM_SOPT2: ESDHCSRC=0 */
  SIM_SOPT2 &= (uint32_t)~(uint32_t)(SIM_SOPT2_ESDHCSRC(0x03));
  /* Set bus clock frequency and data timeout */
  /* SDHC_SYSCTL: ??=0,??=0,??=0,??=0,INITA=0,RSTD=0,RSTC=0,RSTA=0,??=0,??=0,??=0,??=0,DTOCV=0x0E,SDCLKFS=0x10,DVS=0x0C,SDCLKEN=0,PEREN=0,HCKEN=0,IPGEN=0 */
  SDHC_SYSCTL = SDHC_SYSCTL_DTOCV(0x0E) |
                SDHC_SYSCTL_SDCLKFS(0x10) |
                SDHC_SYSCTL_DVS(0x0C);
  while (!SDHC_PDD_IsSDClockStable(SDHC_BASE_PTR)) {} /* Wait for clock to stabilize */
  /* SDHC_SYSCTL: ??=0,??=0,??=0,??=0,INITA=0,RSTD=0,RSTC=0,RSTA=0,??=0,??=0,??=0,??=0,DTOCV=0x0E,SDCLKFS=0x10,DVS=0x0C,SDCLKEN=1,PEREN=1,HCKEN=1,IPGEN=1 */
  SDHC_SYSCTL = SDHC_SYSCTL_DTOCV(0x0E) |
                SDHC_SYSCTL_SDCLKFS(0x10) |
                SDHC_SYSCTL_DVS(0x0C) |
                SDHC_SYSCTL_SDCLKEN_MASK |
                SDHC_SYSCTL_PEREN_MASK |
                SDHC_SYSCTL_HCKEN_MASK |
                SDHC_SYSCTL_IPGEN_MASK;
  /* Set interrupt priorities */
  /* NVICIP80: PRI80=0 */
  NVICIP80 = NVIC_IP_PRI80(0x00);
  /* NVICISER2: SETENA|=0x00010000 */
  NVICISER2 |= NVIC_ISER_SETENA(0x00010000);
  /* Allocate the interrupt vector */
  /* {Default RTOS Adapter} Set interrupt vector: IVT is static, ISR parameter is passed by the global variable */
  INT_SDHC__DEFAULT_RTOS_ISRPARAM = DeviceDataPrv;
  /* Enable and clear status flags */
  /* SDHC_IRQSTAT: ??=1,??=1,??=1,DMAE=1,??=1,??=1,??=1,AC12E=1,??=1,DEBE=1,DCE=1,DTOE=1,CIE=1,CEBE=1,CCE=1,CTOE=1,??=1,??=1,??=1,??=1,??=1,??=1,??=1,CINT=1,CRM=1,CINS=1,BRR=1,BWR=1,DINT=1,BGE=1,TC=1,CC=1 */
  SDHC_IRQSTAT = SDHC_IRQSTAT_DMAE_MASK |
                 SDHC_IRQSTAT_AC12E_MASK |
                 SDHC_IRQSTAT_DEBE_MASK |
                 SDHC_IRQSTAT_DCE_MASK |
                 SDHC_IRQSTAT_DTOE_MASK |
                 SDHC_IRQSTAT_CIE_MASK |
                 SDHC_IRQSTAT_CEBE_MASK |
                 SDHC_IRQSTAT_CCE_MASK |
                 SDHC_IRQSTAT_CTOE_MASK |
                 SDHC_IRQSTAT_CINT_MASK |
                 SDHC_IRQSTAT_CRM_MASK |
                 SDHC_IRQSTAT_CINS_MASK |
                 SDHC_IRQSTAT_BRR_MASK |
                 SDHC_IRQSTAT_BWR_MASK |
                 SDHC_IRQSTAT_DINT_MASK |
                 SDHC_IRQSTAT_BGE_MASK |
                 SDHC_IRQSTAT_TC_MASK |
                 SDHC_IRQSTAT_CC_MASK |
                 0xEE80FE00U;
  /* SDHC_IRQSIGEN: ??=0,??=0,??=0,DMAEIEN=0,??=0,??=0,??=0,AC12EIEN=0,??=0,DEBEIEN=0,DCEIEN=0,DTOEIEN=0,CIEIEN=0,CEBEIEN=0,CCEIEN=0,CTOEIEN=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,CINTIEN=0,CRMIEN=0,CINSIEN=0,BRRIEN=0,BWRIEN=0,DINTIEN=0,BGEIEN=0,TCIEN=1,CCIEN=1 */
  SDHC_IRQSIGEN = (SDHC_IRQSIGEN_TCIEN_MASK | SDHC_IRQSIGEN_CCIEN_MASK);
  /* SDHC_IRQSTATEN: ??=1,??=1,??=1,DMAESEN=1,??=1,??=1,??=1,AC12ESEN=1,??=1,DEBESEN=1,DCESEN=1,DTOESEN=1,CIESEN=1,CEBESEN=1,CCESEN=1,CTOESEN=1,??=1,??=1,??=1,??=1,??=1,??=1,??=1,CINTSEN=1,CRMSEN=0,CINSEN=0,BRRSEN=0,BWRSEN=0,DINTSEN=1,BGESEN=1,TCSEN=1,CCSEN=1 */
  SDHC_IRQSTATEN = SDHC_IRQSTATEN_DMAESEN_MASK |
                   SDHC_IRQSTATEN_AC12ESEN_MASK |
                   SDHC_IRQSTATEN_DEBESEN_MASK |
                   SDHC_IRQSTATEN_DCESEN_MASK |
                   SDHC_IRQSTATEN_DTOESEN_MASK |
                   SDHC_IRQSTATEN_CIESEN_MASK |
                   SDHC_IRQSTATEN_CEBESEN_MASK |
                   SDHC_IRQSTATEN_CCESEN_MASK |
                   SDHC_IRQSTATEN_CTOESEN_MASK |
                   SDHC_IRQSTATEN_CINTSEN_MASK |
                   SDHC_IRQSTATEN_DINTSEN_MASK |
                   SDHC_IRQSTATEN_BGESEN_MASK |
                   SDHC_IRQSTATEN_TCSEN_MASK |
                   SDHC_IRQSTATEN_CCSEN_MASK |
                   0xEE80FE00U;
  /* Power up cards */
  SDHC_PDD_InitCard(SDHC_BASE_PTR);
  while (!SDHC_PDD_IsCardInitComplete(SDHC_BASE_PTR)) {}
  /* Reset cards */
  SDHC_PDD_SetCommandArgument(SDHC_BASE_PTR, 0U);
  SDHC_PDD_SendCommand(SDHC_BASE_PTR,
    SDHC_PDD_CMD0_GO_IDLE_STATE, SDHC_PDD_NO_RESPONSE);
  DeviceDataPrv->Enabled = TRUE;       /* Enable the component */
  /* Registration of the device structure */
  PE_LDD_RegisterDeviceStructure(PE_LDD_COMPONENT_SDHC_ID,DeviceDataPrv);
  return DeviceDataPrv;
}

/*
** ===================================================================
**     Method      :  SDHC_Deinit (component SDHC_LDD)
*/
/*!
**     @brief
**         Deinitializes the device. Switches off the device, frees the
**         device data structure memory, interrupt vectors, etc.
**     @param
**         DeviceDataPtr   - Pointer to the device
**                           data structure.
*/
/* ===================================================================*/
void SDHC_Deinit(LDD_TDeviceData *DeviceDataPtr)
{
  SDHC_TDeviceData *DeviceDataPrv = (SDHC_TDeviceData*)DeviceDataPtr;

  (void)DeviceDataPrv;                 /* Suppress unused variable warning if needed */
  /* Disable interrupts */
  setReg32(SDHC_IRQSIGEN, 0x00);
  setReg32(SDHC_IRQSTATEN, 0x00);
  /* {Default RTOS Adapter} Restore interrupt vector: IVT is static, no code is generated */
  /* Disable the device clock */
  SDHC_PDD_EnableSDHCClock(SDHC_BASE_PTR, PDD_DISABLE);
  /* Reset the device */
  SDHC_PDD_ResetDevice(SDHC_BASE_PTR);
  /* Unregistration of the device structure */
  PE_LDD_UnregisterDeviceStructure(PE_LDD_COMPONENT_SDHC_ID);
  /* Deallocation of the internal device data structure */
  /* {Default RTOS Adapter} Driver memory deallocation: Dynamic allocation is simulated, no deallocation code is generated */
  /* SIM_SCGC3: ESDHC=0 */
  SIM_SCGC3 &= (uint32_t)~(uint32_t)(SIM_SCGC3_ESDHC_MASK);
}

/*
** ===================================================================
**     Method      :  SDHC_Enable (component SDHC_LDD)
*/
/*!
**     @brief
**         Enables the component.
**     @param
**         DeviceDataPtr   - Pointer to the device
**                           data structure.
**     @return
**                         - 
**                           Error code, possible values:
**                           ERR_OK - OK
*/
/* ===================================================================*/
LDD_TError SDHC_Enable(LDD_TDeviceData *DeviceDataPtr)
{
  SDHC_TDeviceData *DeviceDataPrv = (SDHC_TDeviceData*)DeviceDataPtr;

  DeviceDataPrv->Enabled = TRUE;       /* Enable the component */
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  SDHC_Disable (component SDHC_LDD)
*/
/*!
**     @brief
**         Disables the component.
**     @param
**         DeviceDataPtr   - Pointer to the device
**                           data structure.
**     @return
**                         - 
**                           Error code, possible values:
**                           ERR_OK - OK
*/
/* ===================================================================*/
LDD_TError SDHC_Disable(LDD_TDeviceData *DeviceDataPtr)
{
  SDHC_TDeviceData *DeviceDataPrv = (SDHC_TDeviceData*)DeviceDataPtr;

  DeviceDataPrv->Enabled = FALSE;      /* Disable the component */
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  SDHC_SetEventMask (component SDHC_LDD)
*/
/*!
**     @brief
**         Sets event mask.
**     @param
**         DeviceDataPtr   - Pointer to the device
**                           data structure.
**     @param
**         EventMask       - Event mask
**     @return
**                         - 
**                           Error code, possible values:
**                           ERR_OK - OK
**                           ERR_DISABLED - The component is disabled
**                           ERR_SPEED - The component does not work in
**                           the active clock configuration
**                           ERR_PARAM_MASK - Invalid mask (one or more
**                           event is unmaskable)
*/
/* ===================================================================*/
LDD_TError SDHC_SetEventMask(LDD_TDeviceData *DeviceDataPtr, LDD_TEventMask EventMask)
{
  SDHC_TDeviceData *DeviceDataPrv = (SDHC_TDeviceData*)DeviceDataPtr;

  /* Device state test - this test can be disabled by setting the "Ignore enable test"
     property to the "yes" value in the "Configuration inspector" */
  if (!DeviceDataPrv->Enabled) {
    return ERR_DISABLED;
  }
  if ((EventMask & (LDD_TEventMask)(~(LDD_TEventMask)(
      LDD_SDHC_ON_CARD_INSERTED | LDD_SDHC_ON_CARD_REMOVED | LDD_SDHC_ON_FINISHED))) != 0U) {
    return ERR_PARAM_MASK;
  }
  DeviceDataPrv->EventMask = EventMask;
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  SDHC_GetEventMask (component SDHC_LDD)
*/
/*!
**     @brief
**         Returns event mask.
**     @param
**         DeviceDataPtr   - Pointer to the device
**                           data structure.
**     @return
**                         - Current event mask.
*/
/* ===================================================================*/
LDD_TEventMask SDHC_GetEventMask(LDD_TDeviceData *DeviceDataPtr)
{
  SDHC_TDeviceData *DeviceDataPrv = (SDHC_TDeviceData*)DeviceDataPtr;

  return DeviceDataPrv->EventMask;
}

/*
** ===================================================================
**     Method      :  SDHC_DetectCards (component SDHC_LDD)
*/
/*!
**     @brief
**         Detects newly inserted and removed cards. The OnCardInserted
**         event will be called for every new card and the
**         OnCardRemoved event will be called for every removed card.
**         This method should be used when card detection pin is not
**         available.
**     @param
**         DeviceDataPtr   - Pointer to the device
**                           data structure.
**     @return
**                         - 
**                           Error code, possible values:
**                           ERR_OK - Card detection started
**                           ERR_DISABLED - The component is disabled
**                           ERR_SPEED - The component does not work in
**                           the active clock configuration
**                           ERR_BUSY - Another card operation is in
**                           progress
*/
/* ===================================================================*/
LDD_TError SDHC_DetectCards(LDD_TDeviceData *DeviceDataPtr)
{
  SDHC_TDeviceData *DeviceDataPrv = (SDHC_TDeviceData*)DeviceDataPtr;
  LDD_TError Result = ERR_OK;          /* Error code storage */

  /* Device state test - this test can be disabled by setting the "Ignore enable test"
     property to the "yes" value in the "Configuration inspector" */
  if (!DeviceDataPrv->Enabled) {
    return ERR_DISABLED;
  }
  if (DeviceDataPrv->State == LDD_SDHC_IDLE) {
    DeviceDataPrv->Cancel = FALSE;     /* Clear the cancel flag */
    DeviceDataPrv->LastError = LDD_SDHC_ERR_OK; /* Clear the error code */
    DeviceDataPrv->LastErrorAddress = 0U; /* Clear the error address */
    DeviceDataPrv->State = LDD_SDHC_VOLTAGE_VALIDATION;
    DeviceDataPrv->Substate = SDHC_VV_START;
    VoltageValidation(DeviceDataPrv, 0U, SDHC_NO_RESPONSE); /* Handle the voltage validation state */
  } else {
    Result = ERR_BUSY;                 /* Another operation is in progress */
  }
  return Result;
}

/*
** ===================================================================
**     Method      :  SDHC_SelectCard (component SDHC_LDD)
*/
/*!
**     @brief
**         Selects a card by its identification number. All further
**         operations will apply to this card. Special card
**         identification number <compId>_NO_CARD will deselect the
**         active card.
**     @param
**         DeviceDataPtr   - Pointer to the device
**                           data structure.
**     @param
**         Id              - Card identification number passed by the
**                           OnCardInserted event parameter.
**     @return
**                         - 
**                           Error code, possible values:
**                           ERR_OK - Card selection started
**                           ERR_DISABLED - The component is disabled
**                           ERR_SPEED - The component does not work in
**                           the active clock configuration
**                           ERR_BUSY - Another card operation is in
**                           progress
**                           ERR_PARAM_ID - Invalid card ID
*/
/* ===================================================================*/
LDD_TError SDHC_SelectCard(LDD_TDeviceData *DeviceDataPtr, uint8_t Id)
{
  SDHC_TDeviceData *DeviceDataPrv = (SDHC_TDeviceData*)DeviceDataPtr;
  LDD_TError Result = ERR_OK;          /* Error code storage */
  uint32_t Argument;                   /* Card command argument */

  /* Device state test - this test can be disabled by setting the "Ignore enable test"
     property to the "yes" value in the "Configuration inspector" */
  if (!DeviceDataPrv->Enabled) {
    return ERR_DISABLED;
  }
  if (Id != SDHC_NO_CARD) {
    if (!DeviceDataPrv->Cards[Id].Initialized) {
      return ERR_PARAM_ID;
    }
  }
  if (DeviceDataPrv->State == LDD_SDHC_IDLE) {
    DeviceDataPrv->Cancel = FALSE;     /* Clear the cancel flag */
    DeviceDataPrv->LastError = LDD_SDHC_ERR_OK; /* Clear the error code */
    DeviceDataPrv->LastErrorAddress = 0U; /* Clear the error address */
    if (Id != DeviceDataPrv->CardId) {
      /* Change card selection */
      DeviceDataPrv->CardId = Id;
      if (Id != SDHC_NO_CARD) {        /* Select card */
        DeviceDataPrv->CardType = DeviceDataPrv->Cards[Id].Type; /* Store currently selected card's type */
        Argument = SDHC_CMD_ARG_RCA((uint32_t)DeviceDataPrv->Cards[Id].RCA); /* Select card by its RCA */
      } else {                         /* Unselect card */
        Argument = 0U;                 /* Zero is a special RCA (relative card address) for deselecting all cards */
      }
      DeviceDataPrv->State = LDD_SDHC_CARD_SELECTION;
      /* Send card selection command */
      SDHC_PDD_SetCommandArgument(SDHC_BASE_PTR, Argument);
      SDHC_PDD_SendCommand(SDHC_BASE_PTR,
        SDHC_PDD_CMD7_SELECT_CARD, SDHC_PDD_RESPONSE_LENGTH_48_BUSY_CHECK);
    } else {
      Result = ERR_PARAM_ID;           /* Reselecting an already selected card is an illegal card operation */
    }
  } else {
    Result = ERR_BUSY;                 /* Another operation is in progress */
  }
  return Result;
}

/*
** ===================================================================
**     Method      :  SDHC_GetCardInfo (component SDHC_LDD)
*/
/*!
**     @brief
**         Returns card information about the selected card. Method
**         call starts the card information retrieval process. After
**         the card information has been received, the OnFinished event
**         is called (the component state changes to idle) and the
**         information is stored in the specified variable.
**     @param
**         DeviceDataPtr   - Pointer to the device
**                           data structure.
**     @param
**         InfoPtr         - Pointer to a variable, where card
**                           information will be stored.
**     @return
**                         - 
**                           Error code, possible values:
**                           ERR_OK - Card information retrieval started
**                           ERR_DISABLED - The component is disabled
**                           ERR_SPEED - The component does not work in
**                           the active clock configuration
**                           ERR_BUSY - Another card operation is in
**                           progress
*/
/* ===================================================================*/
LDD_TError SDHC_GetCardInfo(LDD_TDeviceData *DeviceDataPtr, LDD_SDHC_TCardInfo *InfoPtr)
{
  SDHC_TDeviceData *DeviceDataPrv = (SDHC_TDeviceData*)DeviceDataPtr;
  LDD_TError Result = ERR_OK;          /* Error code storage */

  /* Device state test - this test can be disabled by setting the "Ignore enable test"
     property to the "yes" value in the "Configuration inspector" */
  if (!DeviceDataPrv->Enabled) {
    return ERR_DISABLED;
  }
  if (DeviceDataPrv->State == LDD_SDHC_IDLE) {
    DeviceDataPrv->Cancel = FALSE;     /* Clear the cancel flag */
    DeviceDataPrv->LastError = LDD_SDHC_ERR_OK; /* Clear the error code */
    DeviceDataPrv->LastErrorAddress = 0U; /* Clear the error address */
    DeviceDataPrv->CardInfoPtr = InfoPtr; /* Store a pointer to the card info variable for later card info update */
    /* Start card information retrieval */
    DeviceDataPrv->State = LDD_SDHC_CARD_INFO_RETRIEVAL;
    DeviceDataPrv->Substate = SDHC_CIR_START;
    CardInfoRetrieval(DeviceDataPrv, 0U, SDHC_NO_RESPONSE); /* Handle the card info retrieval state */
  } else {
    Result = ERR_BUSY;                 /* Another operation is in progress */
  }
  return Result;
}

/*
** ===================================================================
**     Method      :  SDHC_TransferBlocks (component SDHC_LDD)
*/
/*!
**     @brief
**         Initiates a data block transfer on the selected card.
**         Transfer can be a read or write operation depending on the
**         transfer operation parameter. Read operation reads data
**         blocks from the specified address on a memory card and
**         stores their content into buffers specified by the buffer
**         descriptor list. Write operation writes data blocks
**         specified by the buffer descriptor list to a card memory on
**         the specified address. Data blocks should be the same size
**         and the block size should be supported by the memory card.
**         Buffer addresses should be aligned to a hardware specific
**         address boundary.
**     @param
**         DeviceDataPtr   - Pointer to the device
**                           data structure.
**     @param
**         Operation       - Transfer operation
**     @param
**         Address         - Card memory address. Byte address
**                           in case of standard capacity memory cards,
**                           512 byte block number in case of high
**                           capacity memory cards.
**     @param
**         BufferDescListPtr - Pointer to
**                           data block buffer descriptor list.
**     @param
**         BufferDescCount - Data block buffer
**                           descriptor list item count
**     @return
**                         - 
**                           Error code, possible values:
**                           ERR_OK - Transfer started
**                           ERR_DISABLED - The component is disabled
**                           ERR_SPEED - The component does not work in
**                           the active clock configuration
**                           ERR_BUSY - Another card operation is in
**                           progress
**                           ERR_PARAM_ADDRESS - Invalid buffer address
**                           (one or more buffer address from the list
**                           of buffer descriptors is misaligned)
**                           ERR_PARAM_BUFFER_COUNT - Buffer count
**                           exceeds the internal buffer table size
*/
/* ===================================================================*/
LDD_TError SDHC_TransferBlocks(LDD_TDeviceData *DeviceDataPtr, LDD_SDHC_TTransferOperation Operation, uint32_t Address, LDD_SDHC_TBufferDesc *BufferDescListPtr, uint16_t BufferDescCount)
{
  SDHC_TDeviceData *DeviceDataPrv = (SDHC_TDeviceData*)DeviceDataPtr;
  LDD_TError Result = ERR_OK;          /* Error code storage */
  uint32_t Index;                      /* Transfer table index */
  bool Finished;                       /* Indicates whether transfer has finished */

  /* Device state test - this test can be disabled by setting the "Ignore enable test"
     property to the "yes" value in the "Configuration inspector" */
  if (!DeviceDataPrv->Enabled) {
    return ERR_DISABLED;
  }
  if ((BufferDescCount == 0U) || (BufferDescCount > SDHC_BUFFER_TABLE_SIZE)) {
    return ERR_PARAM_BUFFER_COUNT;
  }
  if (DeviceDataPrv->State == LDD_SDHC_IDLE) {
    DeviceDataPrv->Cancel = FALSE;     /* Clear the cancel flag */
    DeviceDataPrv->LastError = LDD_SDHC_ERR_OK; /* Clear the error code */
    DeviceDataPrv->LastErrorAddress = 0U; /* Clear the error address */
    DeviceDataPrv->TransferBlockSize = BufferDescListPtr[0].Size; /* Determine block size from first buffer size */
    DeviceDataPrv->TransferBlockCount = BufferDescCount; /* Determine block count from buffer count */
    /* Fill in the transfer descriptors table */
    for (Index = 0U; Index < BufferDescCount; Index++) {
      DeviceDataPrv->TransferTable[Index].Attributes = /* Mark each transfer buffer descriptor as ready for transfer */
        SDHC_ADMA2_VALID | SDHC_ADMA2_ATTR_ACT_TRAN;
      DeviceDataPrv->TransferTable[Index].Length = BufferDescListPtr[Index].Size; /* Copy transfer buffer size */
      DeviceDataPrv->TransferTable[Index].Address = (uint32_t)BufferDescListPtr[Index].DataPtr; /* Copy transfer buffer address */
    }
    DeviceDataPrv->TransferTable[BufferDescCount - 1U].Attributes |= SDHC_ADMA2_END; /* Mark the last descriptor as last */
    DeviceDataPrv->TransferOperation = Operation; /* Store the transfer operation type */
    DeviceDataPrv->Address = Address;  /* Store the source/destination address for the read/write operation */
    /* Start data transfer */
    DeviceDataPrv->State = LDD_SDHC_TRANSFER;
    DeviceDataPrv->CmdState = SDHC_CMD_DATA_LEN;
    Finished = Transfer(DeviceDataPrv, 0U, SDHC_NO_RESPONSE); /* Handle the transfer state */
    (void)Finished;                    /* The return value is not used */
  } else {
    Result = ERR_BUSY;                 /* Another operation is in progress */
  }
  return Result;
}

/*
** ===================================================================
**     Method      :  SDHC_EraseBlocks (component SDHC_LDD)
*/
/*!
**     @brief
**         Initiates a memory area erasion on the selected card. Erase
**         operation erases a memory area of the specified size from
**         the specified address on a memory card.
**     @param
**         DeviceDataPtr   - Pointer to the device
**                           data structure.
**     @param
**         Address         - Address of the beginning of the
**                           erased area. Byte address in case of
**                           standard capacity memory card and 512 byte
**                           block number in case of high capacity
**                           memory card.
**     @param
**         Size            - Size of the erased area. Byte size in
**                           case of standard capacity memory card and
**                           512 byte blocks count in case of high
**                           capacity memory card.
**     @return
**                         - 
**                           Error code, possible values:
**                           ERR_OK - Erasing started
**                           ERR_DISABLED - The component is disabled
**                           ERR_SPEED - The component does not work in
**                           the active clock configuration
**                           ERR_BUSY - Another card operation is in
**                           progress
*/
/* ===================================================================*/
LDD_TError SDHC_EraseBlocks(LDD_TDeviceData *DeviceDataPtr, uint32_t Address, uint32_t Size)
{
  SDHC_TDeviceData *DeviceDataPrv = (SDHC_TDeviceData*)DeviceDataPtr;
  LDD_TError Result = ERR_OK;          /* Error code storage */
  bool Finished;                       /* Indicates whether erasion has finished */

  /* Device state test - this test can be disabled by setting the "Ignore enable test"
     property to the "yes" value in the "Configuration inspector" */
  if (!DeviceDataPrv->Enabled) {
    return ERR_DISABLED;
  }
  if (DeviceDataPrv->State == LDD_SDHC_IDLE) {
    DeviceDataPrv->Cancel = FALSE;     /* Clear the cancel flag */
    DeviceDataPrv->LastError = LDD_SDHC_ERR_OK; /* Clear the error code */
    DeviceDataPrv->LastErrorAddress = 0U; /* Clear the error address */
    DeviceDataPrv->ErasionStart = Address; /* Store the erasion start address */
    DeviceDataPrv->ErasionEnd = (Address + Size) - 1U; /* Count the erasion end address */
    /* Start data erasion */
    DeviceDataPrv->State = LDD_SDHC_ERASION;
    DeviceDataPrv->Substate = SDHC_E_SET_START;
    Finished = Erasion(DeviceDataPrv, 0U, SDHC_NO_RESPONSE); /* Handle the erasion state */
    (void)Finished;                    /* The return value is not used */
  } else {
    Result = ERR_BUSY;                 /* Another operation is in progress */
  }
  return Result;
}

/*
** ===================================================================
**     Method      :  SDHC_SetDataWidth (component SDHC_LDD)
*/
/*!
**     @brief
**         Initiates a data width setup. The card has to support the
**         specified data width.
**     @param
**         DeviceDataPtr   - Pointer to the device
**                           data structure.
**     @param
**         Width           - Data bus bit count.
**     @return
**                         - 
**                           Error code, possible values:
**                           ERR_OK - Setup started
**                           ERR_DISABLED - The component is disabled
**                           ERR_SPEED - The component does not work in
**                           the active clock configuration
**                           ERR_BUSY - Another card operation is in
**                           progress
**                           ERR_PARAM_WIDTH - Invalid data width
*/
/* ===================================================================*/
LDD_TError SDHC_SetDataWidth(LDD_TDeviceData *DeviceDataPtr, uint8_t Width)
{
  SDHC_TDeviceData *DeviceDataPrv = (SDHC_TDeviceData*)DeviceDataPtr;
  LDD_TError Result = ERR_OK;          /* Error code storage */
  bool Finished;                       /* Indicates whether bus width selection has finished */

  /* Device state test - this test can be disabled by setting the "Ignore enable test"
     property to the "yes" value in the "Configuration inspector" */
  if (!DeviceDataPrv->Enabled) {
    return ERR_DISABLED;
  }
  /* Check allowed data width values */
  if (DeviceDataPrv->CardType == LDD_SDHC_MMC) {
    /* Data widths generaly supported by MMC cards */
    if ((Width != LDD_SDHC_CARD_DATA_WIDTH_1_BIT) &&
        (Width != LDD_SDHC_CARD_DATA_WIDTH_4_BIT) &&
        (Width != LDD_SDHC_CARD_DATA_WIDTH_8_BIT)) {
      return ERR_PARAM_WIDTH;
    }
  } else {
    /* Data widths generaly supported by SD cards */
    if ((Width != LDD_SDHC_CARD_DATA_WIDTH_1_BIT) &&
        (Width != LDD_SDHC_CARD_DATA_WIDTH_4_BIT)) {
      return ERR_PARAM_WIDTH;
    }
  }
  if (DeviceDataPrv->State == LDD_SDHC_IDLE) {
    DeviceDataPrv->Cancel = FALSE;     /* Clear the cancel flag */
    DeviceDataPrv->LastError = LDD_SDHC_ERR_OK; /* Clear the error code */
    DeviceDataPrv->LastErrorAddress = 0U; /* Clear the error address */
    DeviceDataPrv->DataWidth = Width;  /* Store the new data width */
    /* Start data width selection */
    DeviceDataPrv->State = LDD_SDHC_DATA_WIDTH_SELECTION;
    DeviceDataPrv->CmdState = SDHC_CMD_START;
    Finished = DataWidthSelection(DeviceDataPrv, 0U, SDHC_NO_RESPONSE); /* Handle the data width selection state */
    (void)Finished;                    /* The return value is not used */
  } else {
    Result = ERR_BUSY;                 /* Another operation is in progress */
  }
  return Result;
}

/*
** ===================================================================
**     Method      :  SDHC_SelectBusClock (component SDHC_LDD)
*/
/*!
**     @brief
**         Initiates a SD bus clock frequency change. If the frequency
**         is for high speed mode, initiates a high speed mode setup on
**         the selected card. The card has to support the specified bus
**         clock frequency. This method is enabled only if a list of
**         bus clock frequencies is specified.
**     @param
**         DeviceDataPtr   - Pointer to the device
**                           data structure.
**     @param
**         Frequency       - Bus clock frequency identifier.
**     @return
**                         - 
**                           Error code, possible values:
**                           ERR_OK - Setup started
**                           ERR_DISABLED - The component is disabled
**                           ERR_SPEED - The component does not work in
**                           the active clock configuration
**                           ERR_BUSY - Another card operation is in
**                           progress
*/
/* ===================================================================*/
LDD_TError SDHC_SelectBusClock(LDD_TDeviceData *DeviceDataPtr, SDHC_TBusClock Frequency)
{
  SDHC_TDeviceData *DeviceDataPrv = (SDHC_TDeviceData*)DeviceDataPtr;
  LDD_TError Result = ERR_OK;          /* Error code storage */
  uint8_t Id = DeviceDataPrv->CardId;  /* Card ID storage */
  static const uint32_t BusClockList[] = { /* Selectable bus clock frequencies in hertz specified by the timing dialog property */
    360577u,
    25000000u,
    37500000u
  };

  /* Device state test - this test can be disabled by setting the "Ignore enable test"
     property to the "yes" value in the "Configuration inspector" */
  if (!DeviceDataPrv->Enabled) {
    return ERR_DISABLED;
  }
  if (DeviceDataPrv->State == LDD_SDHC_IDLE) {
    DeviceDataPrv->Cancel = FALSE;     /* Clear the cancel flag */
    DeviceDataPrv->LastError = LDD_SDHC_ERR_OK; /* Clear the error code */
    DeviceDataPrv->LastErrorAddress = 0U; /* Clear the error address */
    DeviceDataPrv->Frequency = Frequency; /* Store the new bus clock frequency ID */
    /* Start bus clock selection */
    DeviceDataPrv->State = LDD_SDHC_BUS_CLOCK_SELECTION;
    if (((DeviceDataPrv->Cards[Id].Type == LDD_SDHC_SD) && (BusClockList[Frequency] >= 25000000U)) ||
        ((DeviceDataPrv->Cards[Id].Type == LDD_SDHC_MMC) && (BusClockList[Frequency] >= 20000000U))) {
      /* Card needs speed mode switch */
      DeviceDataPrv->CmdState = SDHC_CMD_START;
    } else {
      /* Card doesn't need speed mode switch */
      DeviceDataPrv->CmdState = SDHC_CMD_FINISH;
    }
    if (BusClockSelection(DeviceDataPrv, 0U, SDHC_NO_RESPONSE)) {
      DeviceDataPrv->State = LDD_SDHC_IDLE;
      if (DeviceDataPrv->EventMask & LDD_SDHC_ON_FINISHED) {
        SDHC_OnFinished(DeviceDataPrv->UserDataPtr); /* Call the user event */
      }
    }
  } else {
    Result = ERR_BUSY;                 /* Another operation is in progress */
  }
  return Result;
}

/*
** ===================================================================
**     Method      :  SDHC_SetVoltage (component SDHC_LDD)
*/
/*!
**     @brief
**         Initiates a bus voltage change. The card has to support the
**         specified voltage.
**     @param
**         DeviceDataPtr   - Pointer to the device
**                           data structure.
**     @param
**         Voltage         - Voltage identifier.
**     @return
**                         - 
**                           Error code, possible values:
**                           ERR_OK - Setup started
**                           ERR_DISABLED - The component is disabled
**                           ERR_SPEED - The component does not work in
**                           the active clock configuration
**                           ERR_BUSY - Another card operation is in
**                           progress
*/
/* ===================================================================*/
LDD_TError SDHC_SetVoltage(LDD_TDeviceData *DeviceDataPtr, LDD_SDHC_TVoltage Voltage)
{
  SDHC_TDeviceData *DeviceDataPrv = (SDHC_TDeviceData*)DeviceDataPtr;
  LDD_TError Result = ERR_OK;          /* Error code storage */
  uint8_t Id;                          /* Card ID storage */

  /* Device state test - this test can be disabled by setting the "Ignore enable test"
     property to the "yes" value in the "Configuration inspector" */
  if (!DeviceDataPrv->Enabled) {
    return ERR_DISABLED;
  }
  if (DeviceDataPrv->State == LDD_SDHC_IDLE) {
    DeviceDataPrv->Cancel = FALSE;     /* Clear the cancel flag */
    DeviceDataPrv->LastError = LDD_SDHC_ERR_OK; /* Clear the error code */
    DeviceDataPrv->LastErrorAddress = 0U; /* Clear the error address */
    /* Start a new voltage validation */
    DeviceDataPrv->State = LDD_SDHC_VOLTAGE_VALIDATION;
    DeviceDataPrv->Substate = SDHC_VV_START;
    DeviceDataPrv->HighVoltage = (Voltage == LDD_SDHC_HIGH_VOLTAGE) ? TRUE : FALSE; /* Store the new voltage configuration */
    /* Remove cards from the device data structure */
    for (Id = 0U; Id < SDHC_MAX_CARD_NUMBER; Id++) {
      if (DeviceDataPrv->Cards[Id].Initialized) {
        DeviceDataPrv->Cards[Id].Initialized = FALSE;
        if (DeviceDataPrv->EventMask & LDD_SDHC_ON_CARD_REMOVED) {
          SDHC_OnCardRemoved(DeviceDataPrv->UserDataPtr, Id); /* Call the user event */
        }
      }
    }
    DeviceDataPrv->CardId = SDHC_NO_CARD; /* No card will be selected */
    /* Send reset command */
    SDHC_PDD_SetCommandArgument(SDHC_BASE_PTR, 0U);
    SDHC_PDD_SendCommand(SDHC_BASE_PTR,
      SDHC_PDD_CMD0_GO_IDLE_STATE, SDHC_PDD_NO_RESPONSE);
  } else {
    Result = ERR_BUSY;                 /* Another operation is in progress */
  }
  return Result;
}

/*
** ===================================================================
**     Method      :  SDHC_SetWriteProtection (component SDHC_LDD)
*/
/*!
**     @brief
**         Initiates a write protection setup for the selected card. If
**         the write protection type is LDD_SDHC_GROUP, write
**         protection will be set for the addressed write protection
**         group. Write protection group size is contained within the
**         card information structure. If the write protection type is
**         LDD_SDHC_CARD, write protection will be set for the whole
**         card and the address parameter will be ignored. Only a whole
**         card write protection clear can remove this protection. The
**         card has to support write protection.
**     @param
**         DeviceDataPtr   - Pointer to the device
**                           data structure.
**     @param
**         Type            - Write protection type.
**     @param
**         Address         - Address of the write protection
**                           group, if the write protection type is
**                           LDD_SDHC_GROUP. Byte address in case of
**                           standard capacity memory card and 512 byte
**                           block number in case of high capacity
**                           memory card.
**     @param
**         Protected       - Indicates whether the
**                           addressed write protection group or card
**                           should be write protected or not.
**     @return
**                         - 
**                           Error code, possible values:
**                           ERR_OK - Setup started
**                           ERR_DISABLED - The component is disabled
**                           ERR_SPEED - The component does not work in
**                           the active clock configuration
**                           ERR_BUSY - Another card operation is in
**                           progress
*/
/* ===================================================================*/
LDD_TError SDHC_SetWriteProtection(LDD_TDeviceData *DeviceDataPtr, LDD_SDHC_TWriteProtectType Type, uint32_t Address, bool Protected)
{
  SDHC_TDeviceData *DeviceDataPrv = (SDHC_TDeviceData*)DeviceDataPtr;
  LDD_TError Result = ERR_OK;          /* Error code storage */
  uint8_t Id = DeviceDataPrv->CardId;  /* Card ID storage */
  bool Finished;                       /* Indicates whether write protection setup has finished */

  /* Device state test - this test can be disabled by setting the "Ignore enable test"
     property to the "yes" value in the "Configuration inspector" */
  if (!DeviceDataPrv->Enabled) {
    return ERR_DISABLED;
  }
  if (DeviceDataPrv->State == LDD_SDHC_IDLE) {
    DeviceDataPrv->Cancel = FALSE;     /* Clear the cancel flag */
    DeviceDataPrv->LastError = LDD_SDHC_ERR_OK; /* Clear the error code */
    DeviceDataPrv->LastErrorAddress = 0U; /* Clear the error address */
    DeviceDataPrv->WriteProtType = Type; /* Store the write protection type to be set */
    DeviceDataPrv->Address = Address;  /* Store the write protection group address */
    DeviceDataPrv->WriteProtFlag = Protected; /* Store whether to clear or set write protection */
    /* Start write protection setup */
    DeviceDataPrv->State = LDD_SDHC_WRITE_PROTECTION_SETUP;
    if (Type == LDD_SDHC_GROUP) {      /* Change sector group write protection */
      DeviceDataPrv->CmdState = SDHC_CMD_START;
    } else {                           /* Change the whole card write protection */
      if (Protected) {
        DeviceDataPrv->Cards[Id].CSD[0] |= SDHC_R2_TMP_WRITE_PROTECT_MASK; /* Set the temporary write protection bit in the CSD (card specific data) register */
      } else {
        DeviceDataPrv->Cards[Id].CSD[0] &= (uint32_t)(~(uint32_t)SDHC_R2_TMP_WRITE_PROTECT_MASK); /* Clear the temporary write protection bit in the CSD (card specific data) register */
      }
      DeviceDataPrv->CmdState = SDHC_CMD_START;
    }
    Finished = WriteProtectionSetup(DeviceDataPrv, 0U, SDHC_NO_RESPONSE); /* Handle the write protection setup state */
    (void)Finished;                    /* The return value is not used */
  } else {
    Result = ERR_BUSY;                 /* Another operation is in progress */
  }
  return Result;
}

/*
** ===================================================================
**     Method      :  SDHC_GetWriteProtection (component SDHC_LDD)
*/
/*!
**     @brief
**         Initiates a write protection mask retrieval for the selected
**         card. After the mask has been received, the OnFinished event
**         is called and the mask is stored in the specified variable.
**         The returned mask contains a bit mask of write protected
**         write protection groups starting at the specified address.
**         The least significant bit represents the status of the first
**         write protection group. Bits of write protection groups out
**         of range are cleared. The card has to support write
**         protection.
**     @param
**         DeviceDataPtr   - Pointer to the device
**                           data structure.
**     @param
**         Address         - Address of the write protection
**                           group. Byte address in case of standard
**                           capacity memory card and 512 byte block
**                           number in case of high capacity memory card.
**     @param
**         MaskPtr         - Pointer to a variable, where the
**                           write protection groups status mask will be
**                           stored.
**     @return
**                         - 
**                           Error code, possible values:
**                           ERR_OK - Write protection mask retrieval
**                           started
**                           ERR_DISABLED - The component is disabled
**                           ERR_SPEED - The component does not work in
**                           the active clock configuration
**                           ERR_BUSY - Another card operation is in
**                           progress
*/
/* ===================================================================*/
LDD_TError SDHC_GetWriteProtection(LDD_TDeviceData *DeviceDataPtr, uint32_t Address, uint32_t *MaskPtr)
{
  SDHC_TDeviceData *DeviceDataPrv = (SDHC_TDeviceData*)DeviceDataPtr;
  LDD_TError Result = ERR_OK;          /* Error code storage */
  bool Finished;                       /* Indicates whether write protection retrieval has finished */

  /* Device state test - this test can be disabled by setting the "Ignore enable test"
     property to the "yes" value in the "Configuration inspector" */
  if (!DeviceDataPrv->Enabled) {
    return ERR_DISABLED;
  }
  if (DeviceDataPrv->State == LDD_SDHC_IDLE) {
    DeviceDataPrv->Cancel = FALSE;     /* Clear the cancel flag */
    DeviceDataPrv->LastError = LDD_SDHC_ERR_OK; /* Clear the error code */
    DeviceDataPrv->LastErrorAddress = 0U; /* Clear the error address */
    DeviceDataPrv->Address = Address;  /* Store the write protection group address */
    DeviceDataPrv->WriteProtMaskPtr = MaskPtr; /* Store a pointer to the write protection mask variable for later update */
    /* Start write protection retrieval */
    DeviceDataPrv->State = LDD_SDHC_WRITE_PROTECTION_RETRIEVAL;
    DeviceDataPrv->CmdState = SDHC_CMD_START;
    Finished = WriteProtectionRetrieval(DeviceDataPrv, 0U, SDHC_NO_RESPONSE); /* Handle the write protection retrieval state */
    (void)Finished;                    /* The return value is not used */
  } else {
    Result = ERR_BUSY;                 /* Another operation is in progress */
  }
  return Result;
}

/*
** ===================================================================
**     Method      :  SDHC_CancelOperation (component SDHC_LDD)
*/
/*!
**     @brief
**         Initiates a cancelation of the ongoing operation. The
**         OnFinished event will be called for the stopped operation.
**     @param
**         DeviceDataPtr   - Pointer to the device
**                           data structure.
**     @return
**                         - 
**                           Error code, possible values:
**                           ERR_OK - Operation cancelation started
**                           ERR_DISABLED - The component is disabled
**                           ERR_SPEED - The component does not work in
**                           the active clock configuration
**                           ERR_NOTAVAIL - No operation is in progress
*/
/* ===================================================================*/
LDD_TError SDHC_CancelOperation(LDD_TDeviceData *DeviceDataPtr)
{
  SDHC_TDeviceData *DeviceDataPrv = (SDHC_TDeviceData*)DeviceDataPtr;
  LDD_TError Result = ERR_OK;          /* Error code storage */

  /* Device state test - this test can be disabled by setting the "Ignore enable test"
     property to the "yes" value in the "Configuration inspector" */
  if (!DeviceDataPrv->Enabled) {
    return ERR_DISABLED;
  }
  if (DeviceDataPrv->State != LDD_SDHC_IDLE) {
    DeviceDataPrv->Cancel = TRUE;      /* Set the cancel flag */
    if (DeviceDataPrv->CmdState == SDHC_CMD_DATA) {
      /* Send stop transmission command */
      SDHC_PDD_SetCommandArgument(SDHC_BASE_PTR, 0U);
      SDHC_PDD_SendCommand(SDHC_BASE_PTR,
        SDHC_PDD_CMD12_STOP_TRANSMISSION, SDHC_PDD_RESPONSE_LENGTH_48_BUSY_CHECK);
    }
  } else {
    Result = ERR_NOTAVAIL;             /* No operation is in progress */
  }
  return Result;
}

/*
** ===================================================================
**     Method      :  SDHC_GetStatus (component SDHC_LDD)
*/
/*!
**     @brief
**         Returns the current component status, specifying the ongoing
**         operation.
**     @param
**         DeviceDataPtr   - Pointer to the device
**                           data structure.
**     @return
**                         -  Component status.
*/
/* ===================================================================*/
LDD_SDHC_TStatus SDHC_GetStatus(LDD_TDeviceData *DeviceDataPtr)
{
  SDHC_TDeviceData *DeviceDataPrv = (SDHC_TDeviceData*)DeviceDataPtr;

  return DeviceDataPrv->State;
}

/*
** ===================================================================
**     Method      :  SDHC_GetError (component SDHC_LDD)
*/
/*!
**     @brief
**         Returns the last error code and the memory address where the
**         error occurred (if applicable).
**     @param
**         DeviceDataPtr   - Pointer to the device
**                           data structure.
**     @param
**         AddressPtr      - Pointer to a variable, where
**                           the error address will be stored.
**     @return
**                         -  The last error code.
*/
/* ===================================================================*/
LDD_SDHC_TError SDHC_GetError(LDD_TDeviceData *DeviceDataPtr, uint32_t *AddressPtr)
{
  SDHC_TDeviceData *DeviceDataPrv = (SDHC_TDeviceData*)DeviceDataPtr;
  LDD_SDHC_TError Error;               /* Error code storage */

  Error = DeviceDataPrv->LastError;
  if (AddressPtr) {
    *AddressPtr = DeviceDataPrv->LastErrorAddress;
  }
  return Error;
}

/*
** ===================================================================
**     Method      :  SDHC_VoltageValidation (component SDHC_LDD)
**
**     Description :
**         Voltage validation state handler.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void VoltageValidation(LDD_TDeviceData *DeviceDataPtr, uint32_t Flags, uint32_t *Response)
{
  SDHC_TDeviceData *DeviceDataPrv = (SDHC_TDeviceData*)DeviceDataPtr;
  LDD_SDHC_TError Error = LDD_SDHC_ERR_OK; /* Error code storage */

  switch (DeviceDataPrv->Substate) {
    case SDHC_VV_START:
      DeviceDataPrv->CardsVoltages = 0;
      /* Start with SD card version 2.0 or later interface conditions check */
      DeviceDataPrv->Substate = SDHC_VV_SDHC_CHECK;
      DeviceDataPrv->CmdState = SDHC_CMD_START;
      VoltageValidation(DeviceDataPrv, 0U, SDHC_NO_RESPONSE); /* Handle the voltage validation state */
      break;
    case SDHC_VV_SDHC_CHECK:
      switch (DeviceDataPrv->CmdState) {
        case SDHC_CMD_START:
          DeviceDataPrv->CmdState = SDHC_CMD_FINISH;
          /* Send interface conditions request command */
          SDHC_PDD_SetCommandArgument(SDHC_BASE_PTR,
            ((DeviceDataPrv->HighVoltage == TRUE) ? /* Propose bus voltage configuration */
              SDHC_IF_COND_HIGH_VOLTAGE_MASK :
              SDHC_IF_COND_LOW_VOLTAGE_MASK) |
            SDHC_IF_COND_CHECK_PATTERN);
          SDHC_PDD_SendCommand(SDHC_BASE_PTR,
            SDHC_PDD_CMD8_SEND_EXT_CSD, SDHC_PDD_RESPONSE_LENGTH_48);
          break;
        case SDHC_CMD_FINISH:
          Error = GetCommandError(DeviceDataPrv, Flags, Response); /* Check host and card error flags */
          if (Error == LDD_SDHC_ERR_OK) {
            DeviceDataPrv->HighCapacity = TRUE; /* Card is an SD card version 2.0 or later (possibly high capacity) */
          } else if (Error == LDD_SDHC_ERR_TIMEOUT) {
            DeviceDataPrv->HighCapacity = FALSE; /* Card is a normal SD or other type of card */
          } else {
            DeviceDataPrv->LastError = Error;
          }
          /* Continue with SD card interface conditions check */
          DeviceDataPrv->Substate = SDHC_VV_SD_CHECK;
          DeviceDataPrv->CmdState = SDHC_CMD_START;
          DeviceDataPrv->RetryCounter = SDHC_VOLT_VALID_RETRY_COUNT; /* Limit the interface conditions request number */
          VoltageValidation(DeviceDataPrv, 0U, SDHC_NO_RESPONSE); /* Handle the voltage validation state */
          break;
        default:
          break;
      }
      break;
    case SDHC_VV_SD_CHECK:
      switch (DeviceDataPrv->CmdState) {
        case SDHC_CMD_START:
          DeviceDataPrv->CmdState = SDHC_CMD_ACMD;
          /* Start application specific command */
          SDHC_PDD_SetCommandArgument(SDHC_BASE_PTR, 0U);
          SDHC_PDD_SendCommand(SDHC_BASE_PTR,
            SDHC_PDD_CMD55_APP_CMD, SDHC_PDD_RESPONSE_LENGTH_48);
          break;
        case SDHC_CMD_ACMD:
          Error = GetCommandError(DeviceDataPrv, Flags, Response); /* Check host and card error flags */
          if ((Error == LDD_SDHC_ERR_OK) || (Error == LDD_SDHC_ERR_INTERNAL_FAILURE)) {
            DeviceDataPrv->CmdState = SDHC_CMD_FINISH;
            /* Send OCR (operation conditions register) request */
            SDHC_PDD_SetCommandArgument(SDHC_BASE_PTR,
              ((DeviceDataPrv->HighCapacity == TRUE) ? SDHC_OCR_HIGH_CAPACITY_MASK : 0U) |
              ((DeviceDataPrv->HighVoltage == TRUE) ? /* Propose bus voltage configuration */
                SDHC_OCR_HIGH_VOLTAGE_MASK :
                SDHC_OCR_LOW_VOLTAGE_MASK));
            SDHC_PDD_SendCommand(SDHC_BASE_PTR,
              SDHC_PDD_ACMD41_SD_APP_OP_COND, SDHC_PDD_RESPONSE_LENGTH_48);
          } else {
            if (Error == LDD_SDHC_ERR_COMMAND_CRC) {
              DeviceDataPrv->LastError = Error;
            }
            /* No more SD card, check MMC cards */
            DeviceDataPrv->Substate = SDHC_VV_MMC_CHECK;
            DeviceDataPrv->CmdState = SDHC_CMD_START;
            DeviceDataPrv->RetryCounter = SDHC_VOLT_VALID_RETRY_COUNT; /* Limit the interface conditions request number */
            VoltageValidation(DeviceDataPrv, 0U, SDHC_NO_RESPONSE); /* Handle the voltage validation state */
          }
          break;
        case SDHC_CMD_FINISH:
          Error = GetCommandError(DeviceDataPrv, Flags, SDHC_NO_RESPONSE); /* Check host error flags */
          if ((Error == LDD_SDHC_ERR_OK) && Response) {
            if (SDHC_R3_OCR_IS_CARD_POWER_UP(Response)) {
              /* Card is powered up, start the registration */
              DeviceDataPrv->CardType = LDD_SDHC_SD;
              DeviceDataPrv->CardsVoltages |= *Response & /* Save card voltage capabilities */
                (SDHC_OCR_HIGH_VOLTAGE_MASK | SDHC_OCR_LOW_VOLTAGE_MASK);
              DeviceDataPrv->HighCapacity = (SDHC_R3_OCR_IS_CARD_HIGH_CAPACITY(Response)) ? TRUE : FALSE;
              DeviceDataPrv->State = LDD_SDHC_CARD_REGISTRATION;
              DeviceDataPrv->Substate = SDHC_CR_START;
              CardRegistration(DeviceDataPrv, 0U, SDHC_NO_RESPONSE); /* Handle the card registration state */
            } else if (DeviceDataPrv->RetryCounter--) {
              /* Card is not powered up yet, resend request */
              DeviceDataPrv->CmdState = SDHC_CMD_START;
              VoltageValidation(DeviceDataPrv, 0U, SDHC_NO_RESPONSE); /* Handle the voltage validation state */
            } else {
              /* Power up reached timeout, check MMC cards */
              DeviceDataPrv->LastError = LDD_SDHC_ERR_TIMEOUT;
              DeviceDataPrv->Substate = SDHC_VV_MMC_CHECK;
              DeviceDataPrv->CmdState = SDHC_CMD_START;
            }
          } else {
            if (Error == LDD_SDHC_ERR_COMMAND_CRC) {
              DeviceDataPrv->LastError = Error;
            }
            /* No response for ACMD41, check MMC cards */
            DeviceDataPrv->Substate = SDHC_VV_MMC_CHECK;
            DeviceDataPrv->CmdState = SDHC_CMD_START;
          }
          if (DeviceDataPrv->Substate == SDHC_VV_MMC_CHECK) {
            DeviceDataPrv->RetryCounter = SDHC_VOLT_VALID_RETRY_COUNT; /* Limit the interface conditions request number */
            /* Send reset command */
            SDHC_PDD_SetCommandArgument(SDHC_BASE_PTR, 0U);
            SDHC_PDD_SendCommand(SDHC_BASE_PTR,
              SDHC_PDD_CMD0_GO_IDLE_STATE, SDHC_PDD_NO_RESPONSE);
          }
          break;
        default:
          break;
      }
      break;
    case SDHC_VV_MMC_CHECK:
      switch (DeviceDataPrv->CmdState) {
        case SDHC_CMD_START:
          DeviceDataPrv->CmdState = SDHC_CMD_FINISH;
          /* Send OCR (operation conditions register) request */
          SDHC_PDD_SetCommandArgument(SDHC_BASE_PTR,
            ((DeviceDataPrv->HighVoltage == TRUE) ? /* Propose bus voltage configuration */
              SDHC_OCR_HIGH_VOLTAGE_MASK :
              SDHC_OCR_LOW_VOLTAGE_MASK) |
            SDHC_OCR_HIGH_CAPACITY_MASK); /* Indicate high capacity card support by the host */
          SDHC_PDD_SendCommand(SDHC_BASE_PTR,
            SDHC_PDD_CMD1_SEND_OP_COND, SDHC_PDD_RESPONSE_LENGTH_48);
          break;
        case SDHC_CMD_FINISH:
          Error = GetCommandError(DeviceDataPrv, Flags, SDHC_NO_RESPONSE); /* Check host error flags */
          if ((Error == LDD_SDHC_ERR_OK) && Response) {
            if (SDHC_R3_OCR_IS_CARD_POWER_UP(Response)) {
              /* Card is powered up, start the registration */
              DeviceDataPrv->CardType = LDD_SDHC_MMC;
              DeviceDataPrv->CardsVoltages |= *Response & /* Save card voltage capabilities */
                (SDHC_OCR_HIGH_VOLTAGE_MASK | SDHC_OCR_LOW_VOLTAGE_MASK);
              DeviceDataPrv->HighCapacity = (SDHC_R3_OCR_IS_CARD_HIGH_CAPACITY(Response)) ? TRUE : FALSE;
              DeviceDataPrv->State = LDD_SDHC_CARD_REGISTRATION;
              DeviceDataPrv->Substate = SDHC_CR_START;
              CardRegistration(DeviceDataPrv, 0U, SDHC_NO_RESPONSE); /* Handle the card registration state */
            } else if (DeviceDataPrv->RetryCounter--) {
              /* Card is not powered up yet, resend request */
              DeviceDataPrv->CmdState = SDHC_CMD_START;
              VoltageValidation(DeviceDataPrv, 0U, SDHC_NO_RESPONSE); /* Handle the voltage validation state */
            } else {
              /* Power up reached timeout, finish */
              DeviceDataPrv->LastError = LDD_SDHC_ERR_TIMEOUT;
              DeviceDataPrv->Substate = SDHC_VV_FINISH;
              VoltageValidation(DeviceDataPrv, 0U, SDHC_NO_RESPONSE); /* Handle the voltage validation state */
            }
          } else {
            if (Error == LDD_SDHC_ERR_COMMAND_CRC) {
              DeviceDataPrv->LastError = Error;
            }
            /* No more MMC card, finish */
            DeviceDataPrv->Substate = SDHC_VV_FINISH;
            VoltageValidation(DeviceDataPrv, 0U, SDHC_NO_RESPONSE); /* Handle the voltage validation state */
          }
          break;
        default:
          break;
      }
      break;
    case SDHC_VV_FINISH:
      DeviceDataPrv->State = LDD_SDHC_IDLE;
      if (DeviceDataPrv->EventMask & LDD_SDHC_ON_FINISHED) {
        SDHC_OnFinished(DeviceDataPrv->UserDataPtr); /* Call the user event */
      }
      break;
    default:
      break;
  }
}

/*
** ===================================================================
**     Method      :  CardRegistration (component SDHC_LDD)
**
**     Description :
**         Card registration state handler.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void CardRegistration(LDD_TDeviceData *DeviceDataPtr, uint32_t Flags, uint32_t *Response)
{
  SDHC_TDeviceData *DeviceDataPrv = (SDHC_TDeviceData*)DeviceDataPtr;
  LDD_SDHC_TError Error = LDD_SDHC_ERR_OK; /* Error code storage */
  uint8_t Id;                          /* Card ID storage */
  uint32_t Index;                      /* Array index */

  switch (DeviceDataPrv->Substate) {
    case SDHC_CR_START:
      switch (DeviceDataPrv->CardType) {
        case LDD_SDHC_SD:
        case LDD_SDHC_MMC:
          /* Send CID register request */
          SDHC_PDD_SetCommandArgument(SDHC_BASE_PTR, 0U);
          SDHC_PDD_SendCommand(SDHC_BASE_PTR,
            SDHC_PDD_CMD2_ALL_SEND_CID, SDHC_PDD_RESPONSE_LENGTH_136);
          DeviceDataPrv->Substate = SDHC_CR_GET_CID;
          break;
        default:
          break;
      }
      break;
    case SDHC_CR_GET_CID:
      switch (DeviceDataPrv->CardType) {
        case LDD_SDHC_SD:
        case LDD_SDHC_MMC:
          Error = GetCommandError(DeviceDataPrv, Flags, SDHC_NO_RESPONSE); /* Check host error flags */
          if ((Error == LDD_SDHC_ERR_OK) && Response) {
            /* Assign a free data structure to the card */
            for (Id = 0U; Id < SDHC_MAX_CARD_NUMBER; Id++) {
              if (!DeviceDataPrv->Cards[Id].Initialized) {
                /* Initialize the data structure */
                DeviceDataPrv->NewCardId = Id; /* Assign a component related ID to the card */
                DeviceDataPrv->Cards[Id].Initialized = TRUE; /* Mark the data structure as used */
                DeviceDataPrv->Cards[Id].Type = DeviceDataPrv->CardType;
                DeviceDataPrv->Cards[Id].CID[0] = Response[0]; /* Store the received card ID */
                DeviceDataPrv->Cards[Id].CID[1] = Response[1];
                DeviceDataPrv->Cards[Id].CID[2] = Response[2];
                DeviceDataPrv->Cards[Id].CID[3] = Response[3];
                for (Index = 0U; Index < sizeof(DeviceDataPrv->Cards[Id].Block); Index++) {
                  DeviceDataPrv->Cards[Id].Block[Index] = 0U; /* Clear the card info block */
                }
                DeviceDataPrv->Cards[Id].HighCapacity = DeviceDataPrv->HighCapacity;
                DeviceDataPrv->Cards[Id].DataWidths = LDD_SDHC_CARD_DATA_WIDTH_1_BIT; /* Initialize supported data widths */
                if (DeviceDataPrv->CardType == LDD_SDHC_SD) {
                  /* Request an RCA (relative card address) from the card */
                  SDHC_PDD_SetCommandArgument(SDHC_BASE_PTR, 0U);
                } else {
                  /* Create a new RCA (relative card address) */
                  DeviceDataPrv->Cards[Id].RCA = (uint16_t)((uint16_t)Id + 2U); /* MMC RCAs must start from 2 */
                  /* Send the RCA (relative card address) to the card */
                  SDHC_PDD_SetCommandArgument(SDHC_BASE_PTR, (uint32_t)((uint32_t)Id + 2U) << 16);
                }
                SDHC_PDD_SendCommand(SDHC_BASE_PTR,
                  SDHC_PDD_CMD3_SET_RELATIVE_ADDR, SDHC_PDD_RESPONSE_LENGTH_48);
                DeviceDataPrv->Substate = SDHC_CR_GET_RCA;
              }
            }
          } else {
            if (Error != LDD_SDHC_ERR_TIMEOUT) {
              DeviceDataPrv->LastError = Error;
            }
            /* No more card for registration */
            DeviceDataPrv->Substate = SDHC_CR_FINISH;
            CardRegistration(DeviceDataPrv, 0U, SDHC_NO_RESPONSE); /* Handle the card registration state */
          }
          break;
        default:
          break;
      }
      break;
    case SDHC_CR_GET_RCA:
      switch (DeviceDataPrv->CardType) {
        case LDD_SDHC_SD:
        case LDD_SDHC_MMC:
          Error = GetCommandError(DeviceDataPrv, Flags, SDHC_NO_RESPONSE); /* Check host error flags */
          if ((Error == LDD_SDHC_ERR_OK) && Response) {
            Id = DeviceDataPrv->NewCardId;
            if (DeviceDataPrv->CardType == LDD_SDHC_SD) {
              DeviceDataPrv->Cards[Id].RCA = SDHC_R6_GET_RCA(Response); /* Store the received RCA (relative card address) */
            }
            if (DeviceDataPrv->EventMask & LDD_SDHC_ON_CARD_INSERTED) {
              SDHC_OnCardInserted(DeviceDataPrv->UserDataPtr, Id); /* Call the user event */
            }
          } else {
            DeviceDataPrv->LastError = Error;
          }
          DeviceDataPrv->State = LDD_SDHC_CARD_REGISTRATION;
          DeviceDataPrv->Substate = SDHC_CR_FINISH;
          CardRegistration(DeviceDataPrv, 0U, SDHC_NO_RESPONSE); /* Handle the card registration state */
          break;
        default:
          break;
      }
      break;
    case SDHC_CR_FINISH:
      switch (DeviceDataPrv->CardType) {
        case LDD_SDHC_SD:
          /* An SD card is registered, finish the voltage validation */
        case LDD_SDHC_MMC:
          /* MMC cards are checked as the last, finish the voltage validation */
          DeviceDataPrv->State = LDD_SDHC_VOLTAGE_VALIDATION;
          DeviceDataPrv->Substate = SDHC_VV_FINISH;
          VoltageValidation(DeviceDataPrv, 0U, SDHC_NO_RESPONSE); /* Handle the voltage validation state */
          break;
        default:
          break;
      }
      break;
    default:
      break;
  }
}

/*
** ===================================================================
**     Method      :  CardInfoRetrieval (component SDHC_LDD)
**
**     Description :
**         Card info retrieval state handler.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void CardInfoRetrieval(LDD_TDeviceData *DeviceDataPtr, uint32_t Flags, uint32_t *Response)
{
  SDHC_TDeviceData *DeviceDataPrv = (SDHC_TDeviceData*)DeviceDataPtr;
  bool Finished = FALSE;               /* Indicates card info retrieval end */
  LDD_SDHC_TError Error = LDD_SDHC_ERR_OK; /* Error code storage */
  LDD_SDHC_TCardInfo *InfoPtr;         /* Card info pointer storage */
  uint8_t Id = DeviceDataPrv->CardId;  /* Card ID storage */
  uint8_t BusWidths;                   /* Supported bus widths storage */
  uint32_t Index;                      /* Array index */

  switch (DeviceDataPrv->Substate) {
    case SDHC_CIR_START:
      if (DeviceDataPrv->CardState != SDHC_STAND_BY) {
        /* Change card state to stand-by */
        DeviceDataPrv->Substate = SDHC_CIR_STAND_BY_STATE;
        /* Send unselect card command */
        SDHC_PDD_SetCommandArgument(SDHC_BASE_PTR, 0U); /* Set 0 as command argument to unselect card */
        SDHC_PDD_SendCommand(SDHC_BASE_PTR,
          SDHC_PDD_CMD7_SELECT_CARD, SDHC_PDD_RESPONSE_LENGTH_48);
      } else {
        DeviceDataPrv->Substate = SDHC_CIR_GET_CSD;
        CardInfoRetrieval(DeviceDataPrv, 0U, SDHC_NO_RESPONSE); /* Handle the card info retrieval state */
      }
      break;
    case SDHC_CIR_STAND_BY_STATE:
      Error = GetCommandError(DeviceDataPrv, Flags, Response); /* Check host and card error flags */
      if (Error != LDD_SDHC_ERR_TIMEOUT) {
        DeviceDataPrv->LastError = Error;
      }
      DeviceDataPrv->CardState = SDHC_STAND_BY;
      DeviceDataPrv->Substate = SDHC_CIR_GET_CSD;
      /* Send CSD (card specific data) request command */
      SDHC_PDD_SetCommandArgument(SDHC_BASE_PTR,
        SDHC_CMD_ARG_RCA((uint32_t)DeviceDataPrv->Cards[Id].RCA)); /* Set the card RCA (relative card address) as command argument */
      SDHC_PDD_SendCommand(SDHC_BASE_PTR,
        SDHC_PDD_CMD9_SEND_CSD, SDHC_PDD_RESPONSE_LENGTH_136);
      break;
    case SDHC_CIR_GET_CSD:
      Error = GetCommandError(DeviceDataPrv, Flags, SDHC_NO_RESPONSE); /* Check host error flags */
      if ((Error == LDD_SDHC_ERR_OK) && Response) {
        /* Store the CSD (card specific data) register contained in the response */
        DeviceDataPrv->Cards[Id].CSD[0] = Response[0];
        DeviceDataPrv->Cards[Id].CSD[1] = Response[1];
        DeviceDataPrv->Cards[Id].CSD[2] = Response[2];
        DeviceDataPrv->Cards[Id].CSD[3] = Response[3];
        /* Change card state to transfer */
        DeviceDataPrv->Substate = SDHC_CIR_TRANSFER_STATE;
        /* Send card selection command */
        SDHC_PDD_SetCommandArgument(SDHC_BASE_PTR,
          SDHC_CMD_ARG_RCA((uint32_t)DeviceDataPrv->Cards[Id].RCA)); /* Set the card RCA (relative card address) as command argument */
        SDHC_PDD_SendCommand(SDHC_BASE_PTR,
          SDHC_PDD_CMD7_SELECT_CARD, SDHC_PDD_RESPONSE_LENGTH_48_BUSY_CHECK);
      } else {
        DeviceDataPrv->LastError = Error;
        Finished = TRUE;
      }
      break;
    case SDHC_CIR_TRANSFER_STATE:
      Error = GetCommandError(DeviceDataPrv, Flags, Response); /* Check host and card error flags */
      if ((Error == LDD_SDHC_ERR_OK) && Response) {
        if (SDHC_R1_IS_READY_FOR_DATA(Response)) {
          DeviceDataPrv->CardState = SDHC_TRANSFER;
          if (DeviceDataPrv->CardType == LDD_SDHC_MMC) {
            if (SDHC_R2_MMC_GET_SPEC_VERS(Response) >= SDHC_MMC_CSD_SPEC_VERS_4_X) {
              DeviceDataPrv->Substate = SDHC_CIR_GET_EXT_CSD;
              DeviceDataPrv->CmdState = SDHC_CMD_START;
            } else {
              DeviceDataPrv->Substate = SDHC_CIR_FINISH;
            }
            CardInfoRetrieval(DeviceDataPrv, 0U, SDHC_NO_RESPONSE); /* Handle the card info retrieval state */
          } else {
            DeviceDataPrv->Substate = SDHC_CIR_GET_SCR;
            DeviceDataPrv->CmdState = SDHC_CMD_START;
            CardInfoRetrieval(DeviceDataPrv, 0U, SDHC_NO_RESPONSE); /* Handle the card info retrieval state */
          }
        } else {
          /* Send status request command */
          SendCardStatusRequest(DeviceDataPrv);
        }
      } else {
        DeviceDataPrv->LastError = Error;
        Finished = TRUE;
      }
      break;
    case SDHC_CIR_GET_EXT_CSD:
      switch (DeviceDataPrv->CmdState) {
        case SDHC_CMD_START:
          DeviceDataPrv->CmdState = SDHC_CMD_FINISH;
          /* Set data transfer size */
          SDHC_PDD_SetBlockSize(SDHC_BASE_PTR, SDHC_EXT_CSD_SIZE);
          SDHC_PDD_SetBlockCount(SDHC_BASE_PTR, 1U);
          /* Set DMA transfer properties */
          DeviceDataPrv->TransferTable[0].Attributes = SDHC_SINGLE_BLOCK_TRANS_ATTRS;
          DeviceDataPrv->TransferTable[0].Length = SDHC_EXT_CSD_SIZE;
          DeviceDataPrv->TransferTable[0].Address = (uint32_t)DeviceDataPrv->Cards[Id].Block;
          SDHC_PDD_SetADMAAddress(SDHC_BASE_PTR, DeviceDataPrv->TransferTable);
          /* Send extended CSD (card specific data) request command */
          SDHC_PDD_SetCommandArgument(SDHC_BASE_PTR, 0U);
          SDHC_PDD_SendCommand(SDHC_BASE_PTR, SDHC_PDD_CMD8_SEND_EXT_CSD,
            SDHC_PDD_ENABLE_DMA | SDHC_PDD_DATA_PRESENT | SDHC_PDD_DATA_READ | SDHC_PDD_RESPONSE_LENGTH_48);
          break;
        case SDHC_CMD_FINISH:
          Error = GetCommandError(DeviceDataPrv, Flags, Response); /* Check host and card error flags */
          if (Error == LDD_SDHC_ERR_OK) {
            DeviceDataPrv->CmdState = SDHC_CMD_DATA;
          } else {
            DeviceDataPrv->LastError = Error;
            Finished = TRUE;
          }
          break;
        case SDHC_CMD_DATA:
          Error = GetCommandError(DeviceDataPrv, Flags, SDHC_NO_RESPONSE); /* Check host error flags */
          if (Error == LDD_SDHC_ERR_OK) {
            /* Start the bus testing procedure */
            DeviceDataPrv->Substate = SDHC_CIR_BUS_TEST_4_BIT_WRITE;
            DeviceDataPrv->CmdState = SDHC_CMD_START;
            CardInfoRetrieval(DeviceDataPrv, 0U, SDHC_NO_RESPONSE); /* Handle the card info retrieval state */
          } else {
            DeviceDataPrv->LastError = Error;
            DeviceDataPrv->LastErrorAddress = SDHC_PDD_GetDMAAddress(SDHC_BASE_PTR);
            Finished = TRUE;
          }
          break;
        default:
          break;
      }
      break;
    case SDHC_CIR_BUS_TEST_4_BIT_WRITE:
    case SDHC_CIR_BUS_TEST_8_BIT_WRITE:
      switch (DeviceDataPrv->CmdState) {
        case SDHC_CMD_START:
          DeviceDataPrv->CmdState = SDHC_CMD_FINISH;
          /* Clear the bus test buffer */
          for (Index = 0U; Index < 8U; Index++) {
            DeviceDataPrv->BusTestPtr[Index] = 0U;
          }
          /* Create the bus test pattern */
          if (DeviceDataPrv->Substate == SDHC_CIR_BUS_TEST_4_BIT_WRITE) {
            DeviceDataPrv->BusTestPtr[0] = 0x5AU;
          } else {
            DeviceDataPrv->BusTestPtr[0] = 0x55U;
            DeviceDataPrv->BusTestPtr[1] = 0xAAU;
          }
          SDHC_PDD_SetDataTransferWidth(SDHC_BASE_PTR,
            (DeviceDataPrv->Substate == SDHC_CIR_BUS_TEST_4_BIT_WRITE) ?
              SDHC_PDD_4_BIT_MODE : SDHC_PDD_8_BIT_MODE);
          /* Set data transfer size */
          SDHC_PDD_SetBlockSize(SDHC_BASE_PTR,
            (DeviceDataPrv->Substate == SDHC_CIR_BUS_TEST_4_BIT_WRITE) ? 4U : 8U);
          SDHC_PDD_SetBlockCount(SDHC_BASE_PTR, 1U);
          /* Set DMA transfer properties */
          DeviceDataPrv->TransferTable[0].Attributes = SDHC_SINGLE_BLOCK_TRANS_ATTRS;
          DeviceDataPrv->TransferTable[0].Length =
            (DeviceDataPrv->Substate == SDHC_CIR_BUS_TEST_4_BIT_WRITE) ? 4U : 8U;
          DeviceDataPrv->TransferTable[0].Address = (uint32_t)DeviceDataPrv->BusTestPtr;
          SDHC_PDD_SetADMAAddress(SDHC_BASE_PTR, DeviceDataPrv->TransferTable);
          /* Send bus testing pattern write command */
          SDHC_PDD_SetCommandArgument(SDHC_BASE_PTR, 0U);
          SDHC_PDD_SendCommand(SDHC_BASE_PTR, SDHC_PDD_CMD19_BUS_TEST_WRITE,
            SDHC_PDD_ENABLE_DMA | SDHC_PDD_DATA_PRESENT | SDHC_PDD_DATA_WRITE | SDHC_PDD_RESPONSE_LENGTH_48);
          break;
        case SDHC_CMD_FINISH:
          Error = GetCommandError(DeviceDataPrv, Flags, Response); /* Check host and card error flags */
          if (Error == LDD_SDHC_ERR_OK) {
            DeviceDataPrv->CmdState = SDHC_CMD_DATA;
          } else {
            DeviceDataPrv->LastError = Error;
            Finished = TRUE;
          }
          break;
        case SDHC_CMD_DATA:
          Error = GetCommandError(DeviceDataPrv, Flags, SDHC_NO_RESPONSE); /* Check host error flags */
          if ((Error == LDD_SDHC_ERR_OK) || (Error == LDD_SDHC_ERR_DATA_CRC)) {
            DeviceDataPrv->Substate =
              (DeviceDataPrv->Substate == SDHC_CIR_BUS_TEST_4_BIT_WRITE) ?
                SDHC_CIR_BUS_TEST_4_BIT_READ : SDHC_CIR_BUS_TEST_8_BIT_READ;
            DeviceDataPrv->CmdState = SDHC_CMD_START;
            CardInfoRetrieval(DeviceDataPrv, 0U, SDHC_NO_RESPONSE); /* Handle the card info retrieval state */
          } else {
            DeviceDataPrv->LastError = Error;
            DeviceDataPrv->LastErrorAddress = SDHC_PDD_GetDMAAddress(SDHC_BASE_PTR);
            Finished = TRUE;
          }
          break;
        default:
          break;
      }
      break;
    case SDHC_CIR_BUS_TEST_4_BIT_READ:
    case SDHC_CIR_BUS_TEST_8_BIT_READ:
      switch (DeviceDataPrv->CmdState) {
        case SDHC_CMD_START:
          DeviceDataPrv->CmdState = SDHC_CMD_FINISH;
          /* Set data transfer size */
          SDHC_PDD_SetBlockSize(SDHC_BASE_PTR,
            (DeviceDataPrv->Substate == SDHC_CIR_BUS_TEST_4_BIT_READ) ? 4U : 8U);
          SDHC_PDD_SetBlockCount(SDHC_BASE_PTR, 1U);
          /* Set DMA transfer properties */
          DeviceDataPrv->TransferTable[0].Attributes = SDHC_SINGLE_BLOCK_TRANS_ATTRS;
          DeviceDataPrv->TransferTable[0].Length =
            (DeviceDataPrv->Substate == SDHC_CIR_BUS_TEST_4_BIT_READ) ? 4U : 8U;
          DeviceDataPrv->TransferTable[0].Address = (uint32_t)DeviceDataPrv->BusTestPtr;
          SDHC_PDD_SetADMAAddress(SDHC_BASE_PTR, DeviceDataPrv->TransferTable);
          /* Send bus testing pattern write command */
          SDHC_PDD_SetCommandArgument(SDHC_BASE_PTR, 0U);
          SDHC_PDD_SendCommand(SDHC_BASE_PTR, SDHC_PDD_CMD14_BUS_TEST_READ,
            SDHC_PDD_ENABLE_DMA | SDHC_PDD_DATA_PRESENT | SDHC_PDD_DATA_READ | SDHC_PDD_RESPONSE_LENGTH_48);
          break;
        case SDHC_CMD_FINISH:
          Error = GetCommandError(DeviceDataPrv, Flags, Response); /* Check host and card error flags */
          if (Error == LDD_SDHC_ERR_OK) {
            DeviceDataPrv->CmdState = SDHC_CMD_DATA;
          } else {
            DeviceDataPrv->LastError = Error;
            Finished = TRUE;
          }
          break;
        case SDHC_CMD_DATA:
          Error = GetCommandError(DeviceDataPrv, Flags, SDHC_NO_RESPONSE); /* Check host error flags */
          if ((Error == LDD_SDHC_ERR_OK) || (Error == LDD_SDHC_ERR_DATA_CRC)) {
            if (DeviceDataPrv->Substate == SDHC_CIR_BUS_TEST_4_BIT_READ) {
              /* XNOR the written bus test pattern with the read bus test result */
              DeviceDataPrv->BusTestPtr[0] = (DeviceDataPrv->BusTestPtr[0] & 0x5AU) |
                ((uint8_t)(~DeviceDataPrv->BusTestPtr[0]) & (uint8_t)(~0x5AU));
              if (DeviceDataPrv->BusTestPtr[0] == 0U) {
                /* 4-bit data bus test succeeded */
                DeviceDataPrv->Substate = SDHC_CIR_BUS_TEST_8_BIT_WRITE;
                DeviceDataPrv->CmdState = SDHC_CMD_START;
                DeviceDataPrv->Cards[Id].DataWidths |= LDD_SDHC_CARD_DATA_WIDTH_4_BIT;
              } else {
                DeviceDataPrv->Substate = SDHC_CIR_FINISH;
              }
            } else {
              /* XNOR the written bus test pattern with the read bus test result */
              DeviceDataPrv->BusTestPtr[0] = (DeviceDataPrv->BusTestPtr[0] & 0x55U) |
                ((uint8_t)(~DeviceDataPrv->BusTestPtr[0]) & (uint8_t)(~0x55U));
              DeviceDataPrv->BusTestPtr[1] = (DeviceDataPrv->BusTestPtr[1] & 0xAAU) |
                ((uint8_t)(~DeviceDataPrv->BusTestPtr[1]) & (uint8_t)(~0xAAU));
              if ((DeviceDataPrv->BusTestPtr[0] == 0U) && (DeviceDataPrv->BusTestPtr[1] == 0U)) {
                /* 8-bit data bus test succeeded */
                DeviceDataPrv->Cards[Id].DataWidths |= LDD_SDHC_CARD_DATA_WIDTH_8_BIT;
              }
              DeviceDataPrv->Substate = SDHC_CIR_FINISH;
            }
          } else {
            DeviceDataPrv->LastError = Error;
            DeviceDataPrv->LastErrorAddress = SDHC_PDD_GetDMAAddress(SDHC_BASE_PTR);
            Finished = TRUE;
          }
          if ((DeviceDataPrv->Substate == SDHC_CIR_FINISH) || Finished) {
            /* Restore the data width */
            switch (DeviceDataPrv->DataWidth) {
              case LDD_SDHC_CARD_DATA_WIDTH_1_BIT:
                SDHC_PDD_SetDataTransferWidth(SDHC_BASE_PTR, SDHC_PDD_1_BIT_MODE);
                break;
              case LDD_SDHC_CARD_DATA_WIDTH_4_BIT:
                SDHC_PDD_SetDataTransferWidth(SDHC_BASE_PTR, SDHC_PDD_4_BIT_MODE);
                break;
              case LDD_SDHC_CARD_DATA_WIDTH_8_BIT:
                SDHC_PDD_SetDataTransferWidth(SDHC_BASE_PTR, SDHC_PDD_8_BIT_MODE);
                break;
              default:
                break;
            }
          }
          if (!Finished) {
            CardInfoRetrieval(DeviceDataPrv, 0U, SDHC_NO_RESPONSE); /* Handle the card info retrieval state */
          }
          break;
        default:
          break;
      }
      break;
    case SDHC_CIR_GET_SCR:
      switch (DeviceDataPrv->CmdState) {
        case SDHC_CMD_START:
          DeviceDataPrv->CmdState = SDHC_CMD_ACMD;
          /* Start application specific command */
          SDHC_PDD_SetCommandArgument(SDHC_BASE_PTR,
            SDHC_CMD_ARG_RCA((uint32_t)DeviceDataPrv->Cards[Id].RCA)); /* Set the card RCA (relative card address) as command argument */
          SDHC_PDD_SendCommand(SDHC_BASE_PTR,
            SDHC_PDD_CMD55_APP_CMD, SDHC_PDD_RESPONSE_LENGTH_48);
          break;
        case SDHC_CMD_ACMD:
          Error = GetCommandError(DeviceDataPrv, Flags, Response); /* Check host and card error flags */
          if (Error == LDD_SDHC_ERR_OK) {
            DeviceDataPrv->CmdState = SDHC_CMD_FINISH;
            /* Set data transfer size */
            SDHC_PDD_SetBlockSize(SDHC_BASE_PTR, SDHC_SCR_SIZE);
            SDHC_PDD_SetBlockCount(SDHC_BASE_PTR, 1U);
            /* Set DMA transfer properties */
            DeviceDataPrv->TransferTable[0].Attributes = SDHC_SINGLE_BLOCK_TRANS_ATTRS;
            DeviceDataPrv->TransferTable[0].Length = SDHC_SCR_SIZE;
            DeviceDataPrv->TransferTable[0].Address = (uint32_t)DeviceDataPrv->Cards[Id].Block;
            SDHC_PDD_SetADMAAddress(SDHC_BASE_PTR, DeviceDataPrv->TransferTable);
            /* Send SCR (SD card configuration register) request command */
            SDHC_PDD_SetCommandArgument(SDHC_BASE_PTR, 0U);
            SDHC_PDD_SendCommand(SDHC_BASE_PTR, SDHC_PDD_ACMD51_SEND_SCR,
              SDHC_PDD_ENABLE_DMA | SDHC_PDD_DATA_PRESENT | SDHC_PDD_DATA_READ | SDHC_PDD_RESPONSE_LENGTH_48);
          } else {
            DeviceDataPrv->LastError = Error;
            Finished = TRUE;
          }
          break;
        case SDHC_CMD_FINISH:
          Error = GetCommandError(DeviceDataPrv, Flags, Response); /* Check host and card error flags */
          if (Error == LDD_SDHC_ERR_OK) {
            DeviceDataPrv->CmdState = SDHC_CMD_DATA;
          } else {
            DeviceDataPrv->LastError = Error;
            Finished = TRUE;
          }
          break;
        case SDHC_CMD_DATA:
          Error = GetCommandError(DeviceDataPrv, Flags, SDHC_NO_RESPONSE); /* Check host error flags */
          if (Error == LDD_SDHC_ERR_OK) {
            if (SDHC_SCR_GET_SD_SPEC((uint32_t)DeviceDataPrv->Cards[Id].Block) != SDHC_SCR_SD_SPEC_VERS_1_0X) {
              /* Check high speed support */
              DeviceDataPrv->Substate = SDHC_CIR_GET_FUNC_STATUS;
              DeviceDataPrv->CmdState = SDHC_CMD_START;
            } else {
              DeviceDataPrv->Substate = SDHC_CIR_FINISH;
            }
            CardInfoRetrieval(DeviceDataPrv, 0U, SDHC_NO_RESPONSE); /* Handle the card info retrieval state */
          } else {
            DeviceDataPrv->LastError = Error;
            DeviceDataPrv->LastErrorAddress = SDHC_PDD_GetDMAAddress(SDHC_BASE_PTR);
            Finished = TRUE;
          }
          break;
        default:
          break;
      }
      break;
    case SDHC_CIR_GET_FUNC_STATUS:
      switch (DeviceDataPrv->CmdState) {
        case SDHC_CMD_START:
          DeviceDataPrv->CmdState = SDHC_CMD_FINISH;
          /* Set data transfer size */
          SDHC_PDD_SetBlockSize(SDHC_BASE_PTR, SDHC_SFS_SIZE);
          SDHC_PDD_SetBlockCount(SDHC_BASE_PTR, 1U);
          /* Set DMA transfer properties */
          DeviceDataPrv->TransferTable[0].Attributes = SDHC_SINGLE_BLOCK_TRANS_ATTRS;
          DeviceDataPrv->TransferTable[0].Length = SDHC_SFS_SIZE;
          DeviceDataPrv->TransferTable[0].Address = (uint32_t)&DeviceDataPrv->Cards[Id].Block[SDHC_SFS_BLOCK_START];
          SDHC_PDD_SetADMAAddress(SDHC_BASE_PTR, DeviceDataPrv->TransferTable);
          /* Send function check command */
          SDHC_PDD_SetCommandArgument(SDHC_BASE_PTR,
            SDHC_SD_CMD6_ARG_MODE(SDHC_SD_CMD6_CHECK_FUNC) |
            SDHC_SD_CMD6_ARG_GROUP_1(SDHC_SD_CMD6_GROUP_1_HIGH_SPEED));
          SDHC_PDD_SendCommand(SDHC_BASE_PTR, SDHC_PDD_CMD6_SWITCH,
            SDHC_PDD_ENABLE_DMA | SDHC_PDD_DATA_PRESENT | SDHC_PDD_DATA_READ | SDHC_PDD_RESPONSE_LENGTH_48);
          break;
        case SDHC_CMD_FINISH:
          Error = GetCommandError(DeviceDataPrv, Flags, Response); /* Check host and card error flags */
          if (Error == LDD_SDHC_ERR_OK) {
            DeviceDataPrv->CmdState = SDHC_CMD_DATA;
          } else {
            DeviceDataPrv->LastError = Error;
            Finished = TRUE;
          }
          break;
        case SDHC_CMD_DATA:
          Error = GetCommandError(DeviceDataPrv, Flags, SDHC_NO_RESPONSE); /* Check host error flags */
          if (Error == LDD_SDHC_ERR_OK) {
            DeviceDataPrv->Substate = SDHC_CIR_FINISH;
            CardInfoRetrieval(DeviceDataPrv, 0U, SDHC_NO_RESPONSE); /* Handle the card info retrieval state */
          } else {
            DeviceDataPrv->LastError = Error;
            DeviceDataPrv->LastErrorAddress = SDHC_PDD_GetDMAAddress(SDHC_BASE_PTR);
            Finished = TRUE;
          }
          break;
        default:
          break;
      }
      break;
    case SDHC_CIR_FINISH:
      Response = DeviceDataPrv->Cards[Id].CSD; /* Get a pointer to card specific data */
      InfoPtr = DeviceDataPrv->CardInfoPtr; /* Get a pointer to the user card info variable */
      InfoPtr->Type = DeviceDataPrv->CardType; /* Get card type from selected card type */
      /* Extract card information from card registers */
      InfoPtr->BlockLength = (uint16_t)((uint16_t)1U << SDHC_R2_GET_READ_BL_LEN(Response)); /* Block length = 2^READ_BL_LEN */
      if ((DeviceDataPrv->CardType != LDD_SDHC_SD) || (SDHC_R2_GET_CSD_STRUCTURE(Response) == SDHC_SD_CSD_VERS_1_0)) {
        /* CSD (card specific data) version 1.0 */
        /* Block count = (C_SIZE + 1) * (2^(C_SIZE_MULT + 2)) */
        InfoPtr->BlockCount = (uint16_t)(SDHC_R2_CSD_V1_GET_C_SIZE(Response) + 1U) *
          (uint16_t)((uint16_t)1U << (SDHC_R2_CSD_V1_GET_C_SIZE_MULT(Response) + 2U));
      } else {
        /* CSD (card specific data) version 2.0 */
        /* Block count = (C_SIZE + 1) * 1k */
        InfoPtr->BlockCount = (SDHC_R2_CSD_V2_GET_C_SIZE(Response) + 1U) * 1024U;
      }
      InfoPtr->Caps.Operations = (uint8_t)(SDHC_R2_GET_CCC(Response) >> 2); /* Shift card command classes to fit into a byte (omitting mandatory classes) */
      InfoPtr->Caps.HighCapacity = DeviceDataPrv->Cards[Id].HighCapacity; /* Get high capacity flag acquired during voltage validation */
      InfoPtr->Caps.LowVoltage = (DeviceDataPrv->CardsVoltages & SDHC_OCR_LOW_VOLTAGE_MASK) ? TRUE : FALSE; /* Get low voltage support flag acquired during voltage validation */
      InfoPtr->Caps.Read.MaxBlockLength = (uint16_t)((uint16_t)1U << SDHC_R2_GET_READ_BL_LEN(Response)); /* Max. read block length = 2^READ_BL_LEN */
      InfoPtr->Caps.Read.MisalignBlock = (SDHC_R2_GET_READ_BLK_MISALIGN(Response)) ? TRUE : FALSE;
      InfoPtr->Caps.Read.PartialBlock = (SDHC_R2_GET_READ_BL_PARTIAL(Response)) ? TRUE : FALSE;
      InfoPtr->Caps.Write.MaxBlockLength = (uint16_t)((uint16_t)1U << SDHC_R2_GET_WRITE_BL_LEN(Response)); /* Max. write block length = 2^WRITE_BL_LEN */
      InfoPtr->Caps.Write.MisalignBlock = (SDHC_R2_GET_WRITE_BLK_MISALIGN(Response)) ? TRUE : FALSE;
      InfoPtr->Caps.Write.PartialBlock = (SDHC_R2_GET_WRITE_BL_PARTIAL(Response)) ? TRUE : FALSE;
      InfoPtr->Caps.WriteProtect.Permanent = (SDHC_R2_GET_PERM_WRITE_PROTECT(Response)) ? TRUE : FALSE;
      if (DeviceDataPrv->CardType == LDD_SDHC_MMC) {
        InfoPtr->Caps.DataWidths = DeviceDataPrv->Cards[Id].DataWidths; /* Get data widths acquired during bus testing procedure */
        InfoPtr->Caps.HighSpeed = (SDHC_R2_MMC_GET_SPEC_VERS(Response) == SDHC_MMC_CSD_SPEC_VERS_4_X) ? TRUE : FALSE; /* High speed supported by MMC cards from version 4.0 */
        /* Erase sector size = (ERASE_GRP_SIZE + 1) * (ERASE_GRP_MULT + 1) */
        InfoPtr->Caps.Erase.SectorSize = (uint16_t)((SDHC_R2_MMC_GET_ERASE_GRP_SIZE(Response) + 1U) *
          (SDHC_R2_MMC_GET_ERASE_GRP_MULT(Response) + 1U));
        /* Get erased memory byte content from the extended CSD (card specific data) register */
        InfoPtr->Caps.Erase.Pattern = DeviceDataPrv->Cards[Id].Block[SDHC_EXT_CSD_ERASED_MEM_CONT_INDEX];
        /* Write protection group size = WP_GRP_SIZE + 1 */
        InfoPtr->Caps.WriteProtect.GroupSize = (uint16_t)((SDHC_R2_GET_WP_GRP_ENABLE(Response)) ?
          (SDHC_R2_MMC_GET_WP_GRP_SIZE(Response) + 1U) : 0U);
      } else {
        BusWidths = (uint8_t)SDHC_SCR_GET_SD_BUS_WIDTHS((uint32_t)DeviceDataPrv->Cards[Id].Block);
        InfoPtr->Caps.DataWidths = (uint8_t) /* Map SCR (SD card configuration register) values to component constants */
          (((BusWidths & SDHC_SCR_SD_BUS_WIDTH_1_BIT_MASK) ? LDD_SDHC_CARD_DATA_WIDTH_1_BIT : 0U) |
          ((BusWidths & SDHC_SCR_SD_BUS_WIDTH_4_BIT_MASK) ? LDD_SDHC_CARD_DATA_WIDTH_4_BIT : 0U));
        if (SDHC_SCR_GET_SD_SPEC((uint32_t)DeviceDataPrv->Cards[Id].Block) == SDHC_SCR_SD_SPEC_VERS_1_0X) {
          /* High speed is not supported in this version of SD card specification */
          InfoPtr->Caps.HighSpeed = FALSE;
        } else {
          /* Get high speed support flag acquired during high speed function check */
          InfoPtr->Caps.HighSpeed = (SDHC_SFS_IS_FUNC_SUPPORTED(
            (uint32_t)&DeviceDataPrv->Cards[Id].Block[SDHC_SFS_BLOCK_START],
            SDHC_SFS_HIGH_SPEED_FUNC_GROUP, SDHC_SFS_HIGH_SPEED_FUNC_INDEX)) ? TRUE : FALSE;
        }
        InfoPtr->Caps.Erase.SectorSize = (uint16_t)(SDHC_R2_SD_GET_SECTOR_SIZE(Response) + 1U);
        InfoPtr->Caps.Erase.Pattern = (uint8_t) /* Erase memory byte content is defined by a data status flag */
          ((SDHC_SCR_GET_DATA_STAT_AFTER_ERASE((uint32_t)DeviceDataPrv->Cards[Id].Block)) ? 0xFFU : 0x00U);
        if (SDHC_R2_GET_CSD_STRUCTURE(Response) == SDHC_SD_CSD_VERS_2_0) {
          /* CSD (card specific data) structure version 2.0 */
          InfoPtr->Caps.WriteProtect.GroupSize = (uint16_t)0U;
        } else {
          /* CSD (card specific data) structure version 1.0 */
          InfoPtr->Caps.WriteProtect.GroupSize = (uint16_t)((SDHC_R2_GET_WP_GRP_ENABLE(Response)) ?
            (SDHC_R2_SD_GET_WP_GRP_SIZE(Response) + 1U) : 0U);
        }
      }
      Finished = TRUE;
      break;
    default:
      break;
  }
  if (Finished) {
    DeviceDataPrv->State = LDD_SDHC_IDLE;
    if (DeviceDataPrv->EventMask & LDD_SDHC_ON_FINISHED) {
      SDHC_OnFinished(DeviceDataPrv->UserDataPtr); /* Call the user event */
    }
  }
}

/*
** ===================================================================
**     Method      :  CardSelection (component SDHC_LDD)
**
**     Description :
**         Card selection state handler.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static bool CardSelection(LDD_TDeviceData *DeviceDataPtr, uint32_t Flags, uint32_t *Response)
{
  SDHC_TDeviceData *DeviceDataPrv = (SDHC_TDeviceData*)DeviceDataPtr;
  bool Finished = FALSE;               /* Indicates card selection end */
  LDD_SDHC_TError Error = LDD_SDHC_ERR_OK; /* Error code storage */
  uint8_t Id = DeviceDataPrv->CardId;  /* Card ID storage */

  Error = GetCommandError(DeviceDataPrv, Flags, Response); /* Check host and card error flags */
  if ((Error == LDD_SDHC_ERR_OK) && Response) {
    if (SDHC_R1_IS_READY_FOR_DATA(Response)) {
      /* By card selection card has changed its state to transfer */
      DeviceDataPrv->CardState = SDHC_TRANSFER;
      Finished = TRUE;
    } else {
      /* Send status request command again */
      SendCardStatusRequest(DeviceDataPrv);
    }
  } else {
    if (Id != SDHC_NO_CARD) {
      DeviceDataPrv->LastError = Error;
      DeviceDataPrv->Cards[Id].Initialized = FALSE;
      DeviceDataPrv->CardId = SDHC_NO_CARD; /* Card has been removed */
      if (DeviceDataPrv->EventMask & LDD_SDHC_ON_CARD_REMOVED) {
        SDHC_OnCardRemoved(DeviceDataPrv->UserDataPtr, Id); /* Call the user event */
      }
    } else {
      if (Error != LDD_SDHC_ERR_TIMEOUT) {
        DeviceDataPrv->LastError = Error;
      }
    }
    Finished = TRUE;
  }
  return Finished;
}

/*
** ===================================================================
**     Method      :  Transfer (component SDHC_LDD)
**
**     Description :
**         Transfer state handler.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static bool Transfer(LDD_TDeviceData *DeviceDataPtr, uint32_t Flags, uint32_t *Response)
{
  SDHC_TDeviceData *DeviceDataPrv = (SDHC_TDeviceData*)DeviceDataPtr;
  bool Finished = FALSE;               /* Indicates transfer end */
  LDD_SDHC_TError Error = LDD_SDHC_ERR_OK; /* Error code storage */

  switch (DeviceDataPrv->CmdState) {
    case SDHC_CMD_DATA_LEN:
      DeviceDataPrv->CmdState = SDHC_CMD_START;
      /* Send block length */
      SDHC_PDD_SetCommandArgument(SDHC_BASE_PTR, DeviceDataPrv->TransferBlockSize);
      SDHC_PDD_SendCommand(SDHC_BASE_PTR,
        SDHC_PDD_CMD16_SET_BLOCKLEN, SDHC_PDD_RESPONSE_LENGTH_48);
      break;
    case SDHC_CMD_START:
      Error = GetCommandError(DeviceDataPrv, Flags, Response); /* Check host and card error flags */
      if (Error == LDD_SDHC_ERR_OK) {
        if (DeviceDataPrv->Cancel) {
          Finished = TRUE;
        } else {
          DeviceDataPrv->CmdState = SDHC_CMD_FINISH;
          SDHC_PDD_SetADMAAddress(SDHC_BASE_PTR, DeviceDataPrv->TransferTable);
          /* Set block attributes */
          SDHC_PDD_SetBlockSize(SDHC_BASE_PTR, DeviceDataPrv->TransferBlockSize);
          SDHC_PDD_SetBlockCount(SDHC_BASE_PTR, DeviceDataPrv->TransferBlockCount);
          /* Send transfer command */
          SDHC_PDD_SetCommandArgument(SDHC_BASE_PTR, DeviceDataPrv->Address);
          SDHC_PDD_SendCommand(SDHC_BASE_PTR,
            ((DeviceDataPrv->TransferOperation == LDD_SDHC_READ) ?
              (uint32_t)((DeviceDataPrv->TransferBlockCount > 1U) ?
                SDHC_PDD_CMD18_READ_MULTIPLE_BLOCK : SDHC_PDD_CMD17_READ_SINGLE_BLOCK) :
              (uint32_t)((DeviceDataPrv->TransferBlockCount > 1U) ?
                SDHC_PDD_CMD25_WRITE_MULTIPLE_BLOCK : SDHC_PDD_CMD24_WRITE_BLOCK)),
            ((DeviceDataPrv->TransferBlockCount > 1U) ?
              (SDHC_PDD_ENABLE_BLOCK_COUNT | SDHC_PDD_ENABLE_AUTO_CMD12 | SDHC_PDD_MULTIPLE_BLOCK) : 0U) |
            SDHC_PDD_ENABLE_DMA | SDHC_PDD_DATA_PRESENT | SDHC_PDD_RESPONSE_LENGTH_48 |
            ((DeviceDataPrv->TransferOperation == LDD_SDHC_READ) ?
              SDHC_PDD_DATA_READ : SDHC_PDD_DATA_WRITE));
        }
      } else {
        DeviceDataPrv->LastError = Error;
        Finished = TRUE;
      }
      break;
    case SDHC_CMD_FINISH:
      Error = GetCommandError(DeviceDataPrv, Flags, Response); /* Check host and card error flags */
      if (Error == LDD_SDHC_ERR_OK) {
        DeviceDataPrv->CmdState = SDHC_CMD_DATA;
      } else {
        DeviceDataPrv->LastError = Error;
        Finished = TRUE;
      }
      break;
    case SDHC_CMD_DATA:
      Error = GetCommandError(DeviceDataPrv, Flags, SDHC_NO_RESPONSE); /* Check host error flags */
      if (Error != LDD_SDHC_ERR_OK) {
        DeviceDataPrv->LastError = Error;
        DeviceDataPrv->LastErrorAddress = SDHC_PDD_GetDMAAddress(SDHC_BASE_PTR);
      }
      DeviceDataPrv->CmdState = SDHC_CMD_ERROR;
      SendCardStatusRequest(DeviceDataPrv);
      break;
    case SDHC_CMD_ERROR:
      Error = GetCommandError(DeviceDataPrv, Flags, Response); /* Check host and card error flags */
      if ((Error == LDD_SDHC_ERR_OK) && Response) {
        if (SDHC_R1_IS_READY_FOR_DATA(Response)) {
          Finished = TRUE;
        } else {
          /* Send status request command again */
          SendCardStatusRequest(DeviceDataPrv);
        }
      } else {
        DeviceDataPrv->LastError = Error;
        Finished = TRUE;
      }
      break;
    default:
      break;
  }
  return Finished;
}

/*
** ===================================================================
**     Method      :  Erasion (component SDHC_LDD)
**
**     Description :
**         Erasion state handler.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static bool Erasion(LDD_TDeviceData *DeviceDataPtr, uint32_t Flags, uint32_t *Response)
{
  SDHC_TDeviceData *DeviceDataPrv = (SDHC_TDeviceData*)DeviceDataPtr;
  bool Finished = FALSE;               /* Indicates erasion end */
  LDD_SDHC_TError Error = LDD_SDHC_ERR_OK; /* Error code storage */

  switch (DeviceDataPrv->Substate) {
    case SDHC_E_SET_START:
      DeviceDataPrv->Substate = SDHC_E_SET_END;
      /* Send tag erase start command */
      SDHC_PDD_SetCommandArgument(SDHC_BASE_PTR, DeviceDataPrv->ErasionStart);
      SDHC_PDD_SendCommand(SDHC_BASE_PTR,
        ((DeviceDataPrv->CardType == LDD_SDHC_MMC) ? /* Handle different command indices for different card types */
          SDHC_PDD_CMD35_TAG_ERASE_GROUP_START : SDHC_PDD_CMD32_TAG_SECTOR_START),
        SDHC_PDD_RESPONSE_LENGTH_48);
      break;
    case SDHC_E_SET_END:
      Error = GetCommandError(DeviceDataPrv, Flags, Response); /* Check host and card error flags */
      if (Error == LDD_SDHC_ERR_OK) {
        DeviceDataPrv->Substate = SDHC_E_EXECUTE;
        /* Send tag erase end command */
        SDHC_PDD_SetCommandArgument(SDHC_BASE_PTR, DeviceDataPrv->ErasionEnd);
        SDHC_PDD_SendCommand(SDHC_BASE_PTR,
          ((DeviceDataPrv->CardType == LDD_SDHC_MMC) ? /* Handle different command indices for different card types */
            SDHC_PDD_CMD36_TAG_ERASE_GROUP_END : SDHC_PDD_CMD33_TAG_SECTOR_END),
          SDHC_PDD_RESPONSE_LENGTH_48);
      } else {
        DeviceDataPrv->LastError = Error;
        Finished = TRUE;
      }
      break;
    case SDHC_E_EXECUTE:
      Error = GetCommandError(DeviceDataPrv, Flags, Response); /* Check host and card error flags */
      if (Error == LDD_SDHC_ERR_OK) {
        DeviceDataPrv->Substate = SDHC_E_FINISH;
        /* Send erase command */
        SDHC_PDD_SetCommandArgument(SDHC_BASE_PTR, 0U);
        SDHC_PDD_SendCommand(SDHC_BASE_PTR,
          SDHC_PDD_CMD38_ERASE, SDHC_PDD_RESPONSE_LENGTH_48_BUSY_CHECK);
      } else {
        DeviceDataPrv->LastError = Error;
        Finished = TRUE;
      }
      break;
    case SDHC_E_FINISH:
      Error = GetCommandError(DeviceDataPrv, Flags, Response); /* Check host and card error flags */
      if ((Error == LDD_SDHC_ERR_OK) && Response) {
        /* Check whether erasion has finished */
        if (SDHC_R1_IS_READY_FOR_DATA(Response)) {
          Finished = TRUE;
        } else {
          /* Send status request command again */
          SendCardStatusRequest(DeviceDataPrv);
        }
      } else {
        DeviceDataPrv->LastError = Error;
        Finished = TRUE;
      }
      break;
    default:
      break;
  }
  return Finished;
}

/*
** ===================================================================
**     Method      :  DataWidthSelection (component SDHC_LDD)
**
**     Description :
**         Data width selection state handler.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static bool DataWidthSelection(LDD_TDeviceData *DeviceDataPtr, uint32_t Flags, uint32_t *Response)
{
  SDHC_TDeviceData *DeviceDataPrv = (SDHC_TDeviceData*)DeviceDataPtr;
  bool Finished = FALSE;               /* Indicates data width selection end */
  LDD_SDHC_TError Error = LDD_SDHC_ERR_OK; /* Error code storage */
  uint8_t Id = DeviceDataPrv->CardId;  /* Card ID storage */
  uint8_t Argument = 0U;               /* Command argument */

  if (DeviceDataPrv->CardType == LDD_SDHC_MMC) {
    switch (DeviceDataPrv->CmdState) {
      case SDHC_CMD_START:
        DeviceDataPrv->CmdState = SDHC_CMD_FINISH;
        /* Map data width to an extended CSD (card specific data) register field value */
        switch (DeviceDataPrv->DataWidth) {
          case LDD_SDHC_CARD_DATA_WIDTH_1_BIT:
            Argument = 0U;
            break;
          case LDD_SDHC_CARD_DATA_WIDTH_4_BIT:
            Argument = 1U;
            break;
          case LDD_SDHC_CARD_DATA_WIDTH_8_BIT:
            Argument = 2U;
            break;
          default:
            break;
        }
        /* Send switch command */
        SDHC_PDD_SetCommandArgument(SDHC_BASE_PTR,
          SDHC_MMC_CMD6_ARG_ACCESS(SDHC_MMC_CMD6_WRITE_BYTES) |
          SDHC_MMC_CMD6_ARG_INDEX(SDHC_EXT_CSD_BUS_WIDTH_INDEX) |
          SDHC_MMC_CMD6_ARG_VALUE(Argument));
        SDHC_PDD_SendCommand(SDHC_BASE_PTR,
          SDHC_PDD_CMD6_SWITCH, SDHC_PDD_RESPONSE_LENGTH_48);
        break;
      case SDHC_CMD_FINISH:
        Error = GetCommandError(DeviceDataPrv, Flags, Response); /* Check host and card error flags */
        if ((Error == LDD_SDHC_ERR_OK) && Response) {
          if (SDHC_R1_IS_READY_FOR_DATA(Response)) {
            /* Map data widths to host register field values */
            switch (DeviceDataPrv->DataWidth) {
              case LDD_SDHC_CARD_DATA_WIDTH_1_BIT:
                SDHC_PDD_SetDataTransferWidth(SDHC_BASE_PTR, SDHC_PDD_1_BIT_MODE);
                break;
              case LDD_SDHC_CARD_DATA_WIDTH_4_BIT:
                SDHC_PDD_SetDataTransferWidth(SDHC_BASE_PTR, SDHC_PDD_4_BIT_MODE);
                break;
              case LDD_SDHC_CARD_DATA_WIDTH_8_BIT:
                SDHC_PDD_SetDataTransferWidth(SDHC_BASE_PTR, SDHC_PDD_8_BIT_MODE);
                break;
              default:
                break;
            }
            Finished = TRUE;
          } else {
            /* Send status request command again */
            SendCardStatusRequest(DeviceDataPrv);
          }
        } else {
          DeviceDataPrv->LastError = Error;
          Finished = TRUE;
        }
        break;
      default:
        break;
    }
  } else {
    switch (DeviceDataPrv->CmdState) {
      case SDHC_CMD_START:
        DeviceDataPrv->CmdState = SDHC_CMD_ACMD;
        /* Start application specific command */
        SDHC_PDD_SetCommandArgument(SDHC_BASE_PTR,
          SDHC_CMD_ARG_RCA(DeviceDataPrv->Cards[Id].RCA));
        SDHC_PDD_SendCommand(SDHC_BASE_PTR,
          SDHC_PDD_CMD55_APP_CMD, SDHC_PDD_RESPONSE_LENGTH_48);
        break;
      case SDHC_CMD_ACMD:
        Error = GetCommandError(DeviceDataPrv, Flags, Response); /* Check host and card error flags */
        if (Error == LDD_SDHC_ERR_OK) {
          DeviceDataPrv->CmdState = SDHC_CMD_FINISH;
          /* Map data widths to card register field values */
          switch (DeviceDataPrv->DataWidth) {
            case LDD_SDHC_CARD_DATA_WIDTH_1_BIT:
              SDHC_PDD_SetCommandArgument(SDHC_BASE_PTR, 0U);
              break;
            case LDD_SDHC_CARD_DATA_WIDTH_4_BIT:
              SDHC_PDD_SetCommandArgument(SDHC_BASE_PTR, 2U);
              break;
            default:
              break;
          }
          /* Send bus width set command */
          SDHC_PDD_SendCommand(SDHC_BASE_PTR,
            SDHC_PDD_ACMD6_SET_BUS_WIDTH, SDHC_PDD_RESPONSE_LENGTH_48);
        } else {
          DeviceDataPrv->LastError = Error;
          Finished = TRUE;
        }
        break;
      case SDHC_CMD_FINISH:
        Error = GetCommandError(DeviceDataPrv, Flags, Response); /* Check host and card error flags */
        if (Error == LDD_SDHC_ERR_OK) {
          /* Map data widths to host register field values */
          switch (DeviceDataPrv->DataWidth) {
            case LDD_SDHC_CARD_DATA_WIDTH_1_BIT:
              SDHC_PDD_SetDataTransferWidth(SDHC_BASE_PTR, SDHC_PDD_1_BIT_MODE);
              break;
            case LDD_SDHC_CARD_DATA_WIDTH_4_BIT:
              SDHC_PDD_SetDataTransferWidth(SDHC_BASE_PTR, SDHC_PDD_4_BIT_MODE);
              break;
            default:
              break;
          }
        } else {
          DeviceDataPrv->LastError = Error;
        }
        Finished = TRUE;
        break;
      default:
        break;
    }
  }
  return Finished;
}

/*
** ===================================================================
**     Method      :  BusClockSelection (component SDHC_LDD)
**
**     Description :
**         Bus clock selection state handler.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static bool BusClockSelection(LDD_TDeviceData *DeviceDataPtr, uint32_t Flags, uint32_t *Response)
{
  SDHC_TDeviceData *DeviceDataPrv = (SDHC_TDeviceData*)DeviceDataPtr;
  bool Finished = FALSE;               /* Indicates bus clock selection end */
  LDD_SDHC_TError Error = LDD_SDHC_ERR_OK; /* Error code storage */
  uint8_t Id = DeviceDataPrv->CardId;  /* Card ID storage */

  switch (DeviceDataPrv->CmdState) {
    case SDHC_CMD_START:
      DeviceDataPrv->CmdState = SDHC_CMD_FINISH;
      if (DeviceDataPrv->Cards[Id].Type == LDD_SDHC_MMC) {
        /* Send switch command */
        SDHC_PDD_SetCommandArgument(SDHC_BASE_PTR,
          SDHC_MMC_CMD6_ARG_ACCESS(SDHC_MMC_CMD6_WRITE_BYTES) |
          SDHC_MMC_CMD6_ARG_INDEX(SDHC_EXT_CSD_HS_TIMING_INDEX) |
          SDHC_MMC_CMD6_ARG_VALUE(1));
        SDHC_PDD_SendCommand(SDHC_BASE_PTR,
          SDHC_PDD_CMD6_SWITCH, SDHC_PDD_RESPONSE_LENGTH_48);
      } else {
        /* Send function switch command */
        SDHC_PDD_SetCommandArgument(SDHC_BASE_PTR,
          SDHC_SD_CMD6_ARG_MODE(SDHC_SD_CMD6_SWITCH_FUNC) |
          SDHC_SD_CMD6_ARG_GROUP_1(SDHC_SD_CMD6_GROUP_1_HIGH_SPEED));
        SDHC_PDD_SendCommand(SDHC_BASE_PTR,
          SDHC_PDD_CMD6_SWITCH, SDHC_PDD_RESPONSE_LENGTH_48_BUSY_CHECK);
      }
      break;
    case SDHC_CMD_FINISH:
      Finished = TRUE;
      Error = GetCommandError(DeviceDataPrv, Flags, Response); /* Check host and card error flags */
      if ((Error == LDD_SDHC_ERR_OK) && Response) {
        if (DeviceDataPrv->CardType == LDD_SDHC_MMC) {
          if (!SDHC_R1_IS_READY_FOR_DATA(Response)) {
            /* Send status request command again */
            SendCardStatusRequest(DeviceDataPrv);
            Finished = FALSE;
          }
        }
      }
      if (Finished) {
        SetBusClockPrescalers(DeviceDataPrv, DeviceDataPrv->Frequency);
      }
      break;
    default:
      break;
  }
  return Finished;
}

/*
** ===================================================================
**     Method      :  WriteProtectionSetup (component SDHC_LDD)
**
**     Description :
**         Write protection setup state handler.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static bool WriteProtectionSetup(LDD_TDeviceData *DeviceDataPtr, uint32_t Flags, uint32_t *Response)
{
  SDHC_TDeviceData *DeviceDataPrv = (SDHC_TDeviceData*)DeviceDataPtr;
  bool Finished = FALSE;               /* Indicates write protection setup end */
  LDD_SDHC_TError Error = LDD_SDHC_ERR_OK; /* Error code storage */
  uint8_t Id = DeviceDataPrv->CardId;  /* Card ID storage */
  uint32_t Index;                      /* Array index */

  if (DeviceDataPrv->WriteProtType == LDD_SDHC_GROUP) {
    switch (DeviceDataPrv->CmdState) {
      case SDHC_CMD_START:
        DeviceDataPrv->CmdState = SDHC_CMD_FINISH;
        /* Send write protection set/clear command */
        SDHC_PDD_SetCommandArgument(SDHC_BASE_PTR, DeviceDataPrv->Address);
        SDHC_PDD_SendCommand(SDHC_BASE_PTR,
          (DeviceDataPrv->WriteProtFlag ? /* Choose write protection set or clear command */
            SDHC_PDD_CMD28_SET_WRITE_PROT : SDHC_PDD_CMD29_CLR_WRITE_PROT),
          SDHC_PDD_RESPONSE_LENGTH_48_BUSY_CHECK);
        break;
      case SDHC_CMD_FINISH:
        Error = GetCommandError(DeviceDataPrv, Flags, Response); /* Check host and card error flags */
        if ((Error == LDD_SDHC_ERR_OK) && Response) {
          if (SDHC_R1_IS_READY_FOR_DATA(Response)) {
            Finished = TRUE;
          } else {
            /* Send status request command again */
            SendCardStatusRequest(DeviceDataPrv);
          }
        } else {
          DeviceDataPrv->LastError = Error;
          Finished = TRUE;
        }
        break;
      default:
        break;
    }
  } else {
    switch (DeviceDataPrv->CmdState) {
      case SDHC_CMD_START:
        DeviceDataPrv->CmdState = SDHC_CMD_FINISH;
        /* Order CSD (card specific data) register bytes from MSB to LSB */
        for (Index = 0U; Index < (SDHC_CSD_SIZE - 1U); Index++) {
          DeviceDataPrv->CSDPtr[(SDHC_CSD_SIZE - 1U) - (Index + 1U)] =
            (uint8_t)((uint32_t)DeviceDataPrv->Cards[Id].CSD[Index / 4U] >> (8 * ((int32_t)Index % 4))) & 0xFFU;
        }
        /* Set block attributes */
        SDHC_PDD_SetBlockSize(SDHC_BASE_PTR, SDHC_CSD_SIZE);
        SDHC_PDD_SetBlockCount(SDHC_BASE_PTR, 1U);
        /* Set DMA transfer properties */
        DeviceDataPrv->TransferTable[0].Attributes = SDHC_SINGLE_BLOCK_TRANS_ATTRS;
        DeviceDataPrv->TransferTable[0].Length = SDHC_CSD_SIZE;
        DeviceDataPrv->TransferTable[0].Address = (uint32_t)DeviceDataPrv->CSDPtr;
        SDHC_PDD_SetADMAAddress(SDHC_BASE_PTR, DeviceDataPrv->TransferTable);
        /* Program CSD (card specific data) register */
        SDHC_PDD_SetCommandArgument(SDHC_BASE_PTR, 0U);
        SDHC_PDD_SendCommand(SDHC_BASE_PTR, SDHC_PDD_CMD27_PROGRAM_CSD,
          SDHC_PDD_ENABLE_DMA | SDHC_PDD_DATA_PRESENT | SDHC_PDD_DATA_WRITE | SDHC_PDD_RESPONSE_LENGTH_48);
        break;
      case SDHC_CMD_FINISH:
        Error = GetCommandError(DeviceDataPrv, Flags, Response); /* Check host and card error flags */
        if (Error == LDD_SDHC_ERR_OK) {
          DeviceDataPrv->CmdState = SDHC_CMD_DATA;
        } else {
          DeviceDataPrv->LastError = Error;
          Finished = TRUE;
        }
        break;
      case SDHC_CMD_DATA:
        Error = GetCommandError(DeviceDataPrv, Flags, SDHC_NO_RESPONSE); /* Check host error flags */
        if (Error != LDD_SDHC_ERR_OK) {
          DeviceDataPrv->LastError = Error;
          DeviceDataPrv->LastErrorAddress = SDHC_PDD_GetDMAAddress(SDHC_BASE_PTR);
        }
        Finished = TRUE;
        break;
      default:
        break;
    }
  }
  return Finished;
}

/*
** ===================================================================
**     Method      :  WriteProtectionRetrieval (component SDHC_LDD)
**
**     Description :
**         Write protection retrieval state handler.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static bool WriteProtectionRetrieval(LDD_TDeviceData *DeviceDataPtr, uint32_t Flags, uint32_t *Response)
{
  SDHC_TDeviceData *DeviceDataPrv = (SDHC_TDeviceData*)DeviceDataPtr;
  bool Finished = FALSE;               /* Indicates write protection retrieval end */
  LDD_SDHC_TError Error = LDD_SDHC_ERR_OK; /* Error code storage */

  switch (DeviceDataPrv->CmdState) {
    case SDHC_CMD_START:
      DeviceDataPrv->CmdState = SDHC_CMD_FINISH;
      /* Set block attributes */
      SDHC_PDD_SetBlockSize(SDHC_BASE_PTR, SDHC_WRITE_PROTECT_MASK_SIZE);
      SDHC_PDD_SetBlockCount(SDHC_BASE_PTR, 1U);
      /* Set DMA transfer properties */
      DeviceDataPrv->TransferTable[0].Attributes = SDHC_SINGLE_BLOCK_TRANS_ATTRS;
      DeviceDataPrv->TransferTable[0].Length = SDHC_WRITE_PROTECT_MASK_SIZE;
      DeviceDataPrv->TransferTable[0].Address = (uint32_t)DeviceDataPrv->WriteProtMaskPtr;
      SDHC_PDD_SetADMAAddress(SDHC_BASE_PTR, DeviceDataPrv->TransferTable);
      /* Send write protection mask request command */
      SDHC_PDD_SetCommandArgument(SDHC_BASE_PTR, DeviceDataPrv->Address);
      SDHC_PDD_SendCommand(SDHC_BASE_PTR, SDHC_PDD_CMD30_SEND_WRITE_PROT,
        SDHC_PDD_ENABLE_DMA | SDHC_PDD_DATA_PRESENT | SDHC_PDD_DATA_READ | SDHC_PDD_RESPONSE_LENGTH_48);
      break;
    case SDHC_CMD_FINISH:
      Error = GetCommandError(DeviceDataPrv, Flags, Response); /* Check host and card error flags */
      if (Error == LDD_SDHC_ERR_OK) {
        DeviceDataPrv->CmdState = SDHC_CMD_DATA;
      } else {
        DeviceDataPrv->LastError = Error;
        Finished = TRUE;
      }
      break;
    case SDHC_CMD_DATA:
      Error = GetCommandError(DeviceDataPrv, Flags, SDHC_NO_RESPONSE); /* Check host error flags */
      if (Error != LDD_SDHC_ERR_OK) {
        DeviceDataPrv->LastError = Error;
        DeviceDataPrv->LastErrorAddress = SDHC_PDD_GetDMAAddress(SDHC_BASE_PTR);
      }
      Finished = TRUE;
      break;
    default:
      break;
  }
  return Finished;
}

/*
** ===================================================================
**     Method      :  SetBusClockPrescalers (component SDHC_LDD)
**
**     Description :
**         Bus clock prescalers setup.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void SetBusClockPrescalers(LDD_TDeviceData *DeviceDataPtr, SDHC_TBusClock Frequency)
{
  SDHC_TDeviceData *DeviceDataPrv = (SDHC_TDeviceData*)DeviceDataPtr;
  static const uint8_t PrescalerValues[][1][2] = { /* Frequency select and divisor values for bus clock frequencies selected by property */
    { { 16U, 12U } }, 
    { { 1U, 2U } }, 
    { { 2U, 0U } }
  };

  SDHC_PDD_EnableSDHCClock(SDHC_BASE_PTR, FALSE);
  SDHC_PDD_SetSDHCClockFrequency(SDHC_BASE_PTR,
    PrescalerValues[Frequency][DeviceDataPrv->SpeedMode][0]);
  SDHC_PDD_SetSDHCClockDivisor(SDHC_BASE_PTR,
    PrescalerValues[Frequency][DeviceDataPrv->SpeedMode][1]);
  while (!SDHC_PDD_IsSDClockStable(SDHC_BASE_PTR)) {} /* Wait for clock to stabilize */
  SDHC_PDD_EnableSDHCClock(SDHC_BASE_PTR, TRUE);
}

/*
** ===================================================================
**     Method      :  GetCommandError (component SDHC_LDD)
**
**     Description :
**         Extracts error code from the device error flags and the card 
**         status response.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static LDD_SDHC_TError GetCommandError(LDD_TDeviceData *DeviceDataPtr, uint32_t Flags, uint32_t *Response)
{
  LDD_SDHC_TError Error = LDD_SDHC_ERR_OK; /* Error code storage */
  uint32_t AutoCMD12ErrorFlags = SDHC_PDD_GetAutoCMD12ErrorFlags(SDHC_BASE_PTR); /* Auto CMD12 error flags */

  (void)DeviceDataPtr;                 /* Suppress unused parameter warning */
  /* Map host error flags to component error codes */
  if ((Flags & (SDHC_PDD_COMMAND_TIMEOUT_ERROR_INT | SDHC_PDD_DATA_TIMEOUT_ERROR_INT)) ||
      ((Flags & SDHC_PDD_AUTO_CMD12_ERROR_INT) && (AutoCMD12ErrorFlags & SDHC_PDD_AUTO_CMD12_TIMEOUT_ERROR))) {
    Error = LDD_SDHC_ERR_TIMEOUT;
  } else if ((Flags & (SDHC_PDD_COMMAND_CRC_ERROR_INT | SDHC_PDD_COMMAND_END_BIT_ERROR_INT |
      SDHC_PDD_COMMAND_INDEX_ERROR_INT)) || ((Flags & SDHC_PDD_AUTO_CMD12_ERROR_INT) &&
      (AutoCMD12ErrorFlags & (SDHC_PDD_AUTO_CMD12_CRC_ERROR | SDHC_PDD_AUTO_CMD12_END_BIT_ERROR | SDHC_PDD_AUTO_CMD12_INDEX_ERROR)))) {
    Error = LDD_SDHC_ERR_COMMAND_CRC;
  } else if (Flags & (SDHC_PDD_DATA_CRC_ERROR_INT | SDHC_PDD_DATA_END_BIT_ERROR_INT)) {
    Error = LDD_SDHC_ERR_DATA_CRC;
  } else if (Flags & SDHC_PDD_DMA_ERROR_INT) {
    Error = LDD_SDHC_ERR_DMA;
  } else {
    Error = LDD_SDHC_ERR_OK;
  }
  if ((Error == LDD_SDHC_ERR_OK) && Response) {
    /* Map card error flags to component error codes */
    if (SDHC_R1_IS_ERASE_RESET(Response) ||
        SDHC_R1_IS_CSD_OVERWRITE(Response) ||
        SDHC_R1_IS_ERASE_SEQ_ERROR(Response) ||
        SDHC_R1_IS_ILLEGAL_COMMAND(Response)) {
      Error = LDD_SDHC_ERR_INTERNAL_FAILURE;
    } else if (SDHC_R1_IS_WP_ERASE_SKIP(Response)) {
      Error = LDD_SDHC_ERR_WP_ERASE_SKIP;
    } else if (SDHC_R1_MMC_IS_OVERRUN(Response) ||
        SDHC_R1_MMC_IS_UNDERRUN(Response) ||
        SDHC_R1_IS_ERROR(Response) ||
        SDHC_R1_IS_CC_ERROR(Response) ||
        SDHC_R1_IS_CARD_ECC_FAILED(Response)) {
      Error = LDD_SDHC_ERR_CARD_FAILURE;
    } else if (SDHC_R1_IS_COM_CRC_ERROR(Response)) {
      Error = LDD_SDHC_ERR_COMMAND_CRC;
    } else if (SDHC_R1_IS_CARD_IS_LOCKED(Response)) {
      Error = LDD_SDHC_ERR_CARD_IS_LOCKED;
    } else if (SDHC_R1_IS_WP_VIOLATION(Response)) {
      Error = LDD_SDHC_ERR_WP_VIOLATION;
    } else if (SDHC_R1_IS_ERASE_PARAM(Response) ||
        SDHC_R1_IS_ADDRESS_MISALIGN(Response)) {
      Error = LDD_SDHC_ERR_ADDRESS_MISALIGN;
    } else if (SDHC_R1_IS_BLOCK_LEN_ERROR(Response)) {
      Error = LDD_SDHC_ERR_BLOCK_LEN_ERROR;
    } else if (SDHC_R1_IS_ADDRESS_OUT_OF_RANGE(Response)) {
      Error = LDD_SDHC_ERR_ADDRESS_OUT_OF_RANGE;
    } else {
      Error = LDD_SDHC_ERR_OK;
    }
  }
  return Error;
}

/*
** ===================================================================
**     Method      :  SendCardStatusRequest (component SDHC_LDD)
**
**     Description :
**         Sends a card status request.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void SendCardStatusRequest(LDD_TDeviceData *DeviceDataPtr)
{
  SDHC_TDeviceData *DeviceDataPrv = (SDHC_TDeviceData*)DeviceDataPtr;
  uint8_t Id = DeviceDataPrv->CardId;  /* Card ID storage */

  /* Send status request command */
  SDHC_PDD_SetCommandArgument(SDHC_BASE_PTR,
    SDHC_CMD_ARG_RCA(DeviceDataPrv->Cards[Id].RCA));
  SDHC_PDD_SendCommand(SDHC_BASE_PTR,
    SDHC_PDD_CMD13_SEND_STATUS, SDHC_PDD_RESPONSE_LENGTH_48);
}

/*
** ===================================================================
**     Method      :  SDHC_Interrupt (component SDHC_LDD)
**
**     Description :
**         The method services the interrupt of the selected peripheral(s)
**         and eventually invokes event(s) of the component.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(SDHC_Interrupt)
{
  /* {Default RTOS Adapter} ISR parameter is passed through the global variable */
  SDHC_TDeviceData* DeviceDataPrv = INT_SDHC__DEFAULT_RTOS_ISRPARAM;

  EventHandler(DeviceDataPrv);
}

/*
** ===================================================================
**     Method      :  EventHandler (component SDHC_LDD)
**
**     Description :
**         Hardware event handler.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void EventHandler(LDD_TDeviceData *DeviceDataPtr)
{
  SDHC_TDeviceData *DeviceDataPrv = (SDHC_TDeviceData*)DeviceDataPtr;
  uint32_t IntFlags = SDHC_PDD_GetInterruptFlags(SDHC_BASE_PTR); /* Store interrupt flags */
  const uint32_t CompletionFlags = SDHC_PDD_COMMAND_COMPLETE_INT |
    SDHC_PDD_TRANSFER_COMPLETE_INT | SDHC_PDD_BUFFER_READ_READY_INT |
    SDHC_PDD_BUFFER_WRITE_READY_INT;
  const uint32_t CommandErrorFlags = SDHC_PDD_COMMAND_TIMEOUT_ERROR_INT | /* Command error interrupt flags mask */
    SDHC_PDD_COMMAND_CRC_ERROR_INT | SDHC_PDD_COMMAND_INDEX_ERROR_INT |
    SDHC_PDD_AUTO_CMD12_ERROR_INT;
  const uint32_t DataErrorFlags = SDHC_PDD_DATA_TIMEOUT_ERROR_INT | /* Data transfer error interrupt flags mask */
    SDHC_PDD_DATA_CRC_ERROR_INT | SDHC_PDD_DATA_END_BIT_ERROR_INT |
    SDHC_PDD_DMA_ERROR_INT;
  const uint32_t ErrorFlags = CommandErrorFlags | DataErrorFlags; /* Error interrupt flags mask */
  bool Finished = FALSE;               /* Indicates operation end */
  uint32_t Buffer[4];                  /* Response buffer */
  uint32_t *Response = SDHC_NO_RESPONSE; /* Response buffer pointer */

  if (IntFlags & (CompletionFlags | ErrorFlags)) {
    if (IntFlags & SDHC_PDD_COMMAND_COMPLETE_INT) {
      SDHC_PDD_ClearInterruptFlags(SDHC_BASE_PTR, SDHC_PDD_COMMAND_COMPLETE_INT);
      /* Check command completion errors */
      if (IntFlags & CommandErrorFlags) {
        SDHC_PDD_ClearInterruptFlags(SDHC_BASE_PTR, CommandErrorFlags);
        Response = SDHC_NO_RESPONSE;   /* No valid response has been received */
      } else {
        SDHC_PDD_GetCommandResponse(SDHC_BASE_PTR, Buffer);
        Response = Buffer;             /* Assign the response pointer */
      }
    } else {
      if (IntFlags & SDHC_PDD_TRANSFER_COMPLETE_INT) {
        SDHC_PDD_ClearInterruptFlags(SDHC_BASE_PTR, SDHC_PDD_TRANSFER_COMPLETE_INT | DataErrorFlags);
      }
    }
    switch (DeviceDataPrv->State) {
      case LDD_SDHC_RESET:
        Finished = TRUE;
        break;
      case LDD_SDHC_VOLTAGE_VALIDATION:
        VoltageValidation(DeviceDataPrv, IntFlags, Response); /* Handle the voltage validation state */
        break;
      case LDD_SDHC_CARD_REGISTRATION:
        CardRegistration(DeviceDataPrv, IntFlags, Response); /* Handle the card registration state */
        break;
      case LDD_SDHC_CARD_INFO_RETRIEVAL:
        CardInfoRetrieval(DeviceDataPrv, IntFlags, Response); /* Handle the card info retrieval state */
        break;
      case LDD_SDHC_CARD_SELECTION:
        Finished = CardSelection(DeviceDataPrv, IntFlags, Response); /* Handle the card selection state */
        break;
      case LDD_SDHC_TRANSFER:
        Finished = Transfer(DeviceDataPrv, IntFlags, Response); /* Handle the transfer state */
        break;
      case LDD_SDHC_ERASION:
        Finished = Erasion(DeviceDataPrv, IntFlags, Response); /* Handle the erasion state */
        break;
      case LDD_SDHC_DATA_WIDTH_SELECTION:
        Finished = DataWidthSelection(DeviceDataPrv, IntFlags, Response); /* Handle the data width selection state */
        break;
      case LDD_SDHC_BUS_CLOCK_SELECTION:
        Finished = BusClockSelection(DeviceDataPrv, IntFlags, Response); /* Handle the bus clock selection state */
        break;
      case LDD_SDHC_WRITE_PROTECTION_SETUP:
        Finished = WriteProtectionSetup(DeviceDataPrv, IntFlags, Response); /* Handle the write protection setup state */
        break;
      case LDD_SDHC_WRITE_PROTECTION_RETRIEVAL:
        Finished = WriteProtectionRetrieval(DeviceDataPrv, IntFlags, Response); /* Handle the write protection retrieval state */
        break;
      default:
        break;
    }
  }
  if (Finished) {
    DeviceDataPrv->State = LDD_SDHC_IDLE;
    if (DeviceDataPrv->EventMask & LDD_SDHC_ON_FINISHED) {
      SDHC_OnFinished(DeviceDataPrv->UserDataPtr); /* Call the user event */
    }
  }
}

/*lint -restore  +esym(960,10.1) Enable MISRA rule (10.1,12.1) checking. */

/* END SDHC */

#ifdef __cplusplus
}  /* extern "C" */
#endif 

/*!
** @}
*/
/*
** ###################################################################
**
**     This file was created by Processor Expert 10.3 [05.09]
**     for the Freescale Kinetis series of microcontrollers.
**
** ###################################################################
*/
